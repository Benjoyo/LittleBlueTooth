/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/CustomOperator/Listen.swift:
    1|       |//
    2|       |//  Listen.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 26/08/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Combine
   10|       |import os.log
   11|       |#if TEST
   12|       |import CoreBluetoothMock
   13|       |#else
   14|       |import CoreBluetooth
   15|       |#endif
   16|       |
   17|       |
   18|       |// MARK: - Listen
   19|       |
   20|       |extension Publisher where Self.Failure == LittleBluetoothError {
   21|       |
   22|       |    /// Returns a  publisher with the `LittleBlueToothCharacteristic` where the notify command has been activated.
   23|       |    /// After starting the listen command you should subscribe to the `listenPublisher` to be notified.
   24|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   25|       |    /// - parameter characteristic: Characteristc you want to be notified.
   26|       |    /// - returns: A  publisher with the `LittleBlueToothCharacteristic` where the notify command has been activated.
   27|       |    /// - important: This publisher only activate the notification on a specific characteristic, it will not send notified values.
   28|       |    /// After starting the listen command you should subscribe to the `listenPublisher` to be notified.
   29|       |    public func enableListen(for littleBluetooth: LittleBlueTooth,
   30|      2|                             from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> {
   31|      2|        
   32|      2|        func enableListen<Upstream: Publisher>(upstream: Upstream,
   33|      2|                                               for littleBluetooth: LittleBlueTooth,
   34|      2|                                               from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> where Upstream.Failure == LittleBluetoothError {
   35|      2|            return upstream
   36|      2|                .flatMapLatest { _ in
   37|      2|                    littleBluetooth.enableListen(from: characteristic)
   38|      2|            }
   39|      2|        }
   40|      2|        
   41|      2|        return enableListen(upstream: self,
   42|      2|                            for: littleBluetooth,
   43|      2|                            from: characteristic)
   44|      2|    }
   45|       |    
   46|       |    /// Returns a shared publisher for listening to a specific characteristic.
   47|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   48|       |    /// - parameter characteristic: Characteristc you want to be notified.
   49|       |    /// - returns: A shared publisher that will send out values of the type defined by the generic type.
   50|       |    /// - important: The type of the value must be conform to `Readable`
   51|       |    public func startListen<T: Readable>(for littleBluetooth: LittleBlueTooth,
   52|      1|                                         from charact: LittleBlueToothCharacteristic) -> AnyPublisher<T, LittleBluetoothError> {
   53|      1|        
   54|      1|        func startListen<T: Readable, Upstream: Publisher>(upstream: Upstream,
   55|      1|                                                           for littleBluetooth: LittleBlueTooth,
   56|      1|                                                           from charact: LittleBlueToothCharacteristic) -> AnyPublisher<T, LittleBluetoothError> where Upstream.Failure == LittleBluetoothError {
   57|      1|            return upstream
   58|      1|                .flatMapLatest { _ in
   59|      1|                    littleBluetooth.startListen(from: charact)
   60|      1|            }
   61|      1|        }
   62|      1|        
   63|      1|        return startListen(upstream: self,
   64|      1|                           for: littleBluetooth,
   65|      1|                           from: charact)
   66|      1|    }
   67|       |
   68|       |    /// Disable listen from a specific characteristic
   69|       |    /// - parameter characteristic: characteristic you want to stop listen
   70|       |    /// - returns: A publisher with that informs you about the successful or failed task
   71|       |    public func disableListen(for littleBluetooth: LittleBlueTooth,
   72|      2|                              from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> {
   73|      2|        func disableListen<Upstream: Publisher>(upstream: Upstream,
   74|      2|                                                for littleBluetooth: LittleBlueTooth,
   75|      2|                                                from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> where Upstream.Failure == LittleBluetoothError {
   76|      2|            return upstream
   77|      2|                .flatMapLatest { _ in
   78|      2|                    littleBluetooth.disableListen(from: characteristic)
   79|      2|            }
   80|      2|        }
   81|      2|        return disableListen(upstream: self,
   82|      2|                             for: littleBluetooth,
   83|      2|                             from: characteristic)
   84|      2|    }
   85|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/CustomOperator/Log.swift:
    1|       |//
    2|       |//  Log.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 29/01/21.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Combine
   10|       |
   11|       |extension Publisher {
   12|    410|    func customPrint(_ prefix: String = "", to: TextOutputStream? = nil, isEnabled: Bool = true) -> AnyPublisher<Self.Output, Self.Failure> {
   13|    410|        if isEnabled {
   14|    410|            return print(prefix, to: to).eraseToAnyPublisher()
   15|    410|        }
   16|      0|        return AnyPublisher(self)
   17|    410|    }
   18|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/CustomOperator/ReadAndWrite.swift:
    1|       |//
    2|       |//  ReadAndWrite.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 26/08/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Combine
   10|       |import os.log
   11|       |#if TEST
   12|       |import CoreBluetoothMock
   13|       |#else
   14|       |import CoreBluetooth
   15|       |#endif
   16|       |
   17|       |extension Publisher where Self.Failure == LittleBluetoothError {
   18|       |    // MARK: - RSSI
   19|       |    /// Returns a  publisher with the `Int`value of the RSSI.
   20|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   21|       |    /// - returns: A  publisher with the `Int` value of the RSSI..
   22|      1|    public func readRSSI(for littleBluetooth: LittleBlueTooth) -> AnyPublisher<Int, LittleBluetoothError> {
   23|      1|        
   24|      1|        func readRSSI<Upstream: Publisher>(upstream: Upstream,
   25|      1|                                           for littleBluetooth: LittleBlueTooth) -> AnyPublisher<Int, LittleBluetoothError> where Upstream.Failure == LittleBluetoothError {
   26|      1|            return upstream
   27|      1|                .flatMapLatest { _ in
   28|      1|                    littleBluetooth.readRSSI()
   29|      1|            }
   30|      1|        }
   31|      1|        return readRSSI(upstream: self,
   32|      1|                        for: littleBluetooth)
   33|      1|    }
   34|       |    
   35|       |    // MARK: - Read
   36|       |    
   37|       |    /// Read a value from a specific charteristic
   38|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   39|       |    /// - parameter characteristic: characteristic where you want to read
   40|       |    /// - returns: A publisher with the value you want to read.
   41|       |    /// - important: The type of the value must be conform to `Readable`
   42|       |    public func read<T: Readable>(for littleBluetooth: LittleBlueTooth,
   43|      3|                                  from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<T, LittleBluetoothError> {
   44|      3|        
   45|      3|        func read<T: Readable, Upstream: Publisher>(upstream: Upstream,
   46|      3|                                                    for littleBluetooth: LittleBlueTooth,
   47|      3|                                                    from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<T, LittleBluetoothError> where Upstream.Failure == LittleBluetoothError {
   48|      3|            return upstream
   49|      3|                .flatMapLatest { _ in
   50|      3|                    littleBluetooth.read(from: characteristic)
   51|      3|            }
   52|      3|        }
   53|      3|        
   54|      3|        return read(upstream: self,
   55|      3|                    for: littleBluetooth,
   56|      3|                    from: characteristic)
   57|      3|    }
   58|       |    
   59|       |    // MARK: - Write
   60|       |
   61|       |    /// Write a value to a specific charteristic
   62|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   63|       |    /// - parameter characteristic: characteristic where you want to write
   64|       |    /// - parameter value: The value you want to write
   65|       |    /// - parameter response: An optional `Bool` value that will look for error after write operation
   66|       |    /// - returns: A publisher with that informs you about eventual error
   67|       |    /// - important: The type of the value must be conform to `Writable`
   68|       |    public func write<T: Writable>(for littleBluetooth: LittleBlueTooth,
   69|       |                                   to characteristic: LittleBlueToothCharacteristic,
   70|       |                                   value: T,
   71|      1|                                   response: Bool = true) -> AnyPublisher<Void, LittleBluetoothError> {
   72|      1|        
   73|      1|        func write<T: Writable, Upstream: Publisher>(upstream: Upstream,
   74|      1|                                                     for littleBluetooth: LittleBlueTooth,
   75|      1|                                                     to characteristic: LittleBlueToothCharacteristic,
   76|      1|                                                     value: T,
   77|      1|                                                     response: Bool = true) -> AnyPublisher<Void, LittleBluetoothError> where  Upstream.Failure == LittleBluetoothError {
   78|      1|            return upstream
   79|      1|                .flatMapLatest { _ in
   80|      1|                    littleBluetooth.write(to: characteristic, value: value, response: response)
   81|      1|            }
   82|      1|        }
   83|      1|        
   84|      1|        return write(upstream: self,
   85|      1|                     for: littleBluetooth,
   86|      1|                     to: characteristic,
   87|      1|                     value: value,
   88|      1|                     response: response)
   89|      1|    }
   90|       |    
   91|       |    /// Write a value to a specific charteristic and wait for a response
   92|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   93|       |    /// - parameter characteristic: characteristic where you want to write and listen
   94|       |    /// - parameter value: The value you want to write must conform to `Writable`
   95|       |    /// - returns: A publisher with that post and error or the response of the write requests.
   96|       |    /// - important: Written value must conform to `Writable`, response must conform to `Readable`
   97|       |    public func writeAndListen<W: Writable, R: Readable>(for littleBluetooth: LittleBlueTooth,
   98|       |                                                         from characteristic: LittleBlueToothCharacteristic,
   99|      1|                                                         value: W) -> AnyPublisher<R, LittleBluetoothError> {
  100|      1|        func writeAndListen<W: Writable, R: Readable, Upstream: Publisher>(upstream: Upstream,
  101|      1|                                                                           for littleBluetooth: LittleBlueTooth,
  102|      1|                                                                           from characteristic: LittleBlueToothCharacteristic,
  103|      1|                                                                           value: W) -> AnyPublisher<R, LittleBluetoothError> where  Upstream.Failure == LittleBluetoothError {
  104|      1|           return upstream
  105|      1|                .flatMapLatest { _ in
  106|      1|                    littleBluetooth.writeAndListen(from: characteristic,
  107|      1|                                                   value: value)
  108|      1|            }
  109|      1|        }
  110|      1|        return writeAndListen(upstream: self,
  111|      1|                              for: littleBluetooth,
  112|      1|                              from: characteristic,
  113|      1|                              value: value)
  114|      1|    }
  115|       |    
  116|       |}
  117|       |

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/CustomOperator/ScanAndConnection.swift:
    1|       |//
    2|       |//  Connection.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 26/08/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Combine
   10|       |import os.log
   11|       |#if TEST
   12|       |import CoreBluetoothMock
   13|       |#else
   14|       |import CoreBluetooth
   15|       |#endif
   16|       |
   17|       |// MARK: - Discover
   18|       |extension Publisher where Self.Failure == LittleBluetoothError {
   19|       |    /// Starts scanning for `PeripheralDiscovery`
   20|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   21|       |    /// - parameter services: Services for peripheral you are looking for
   22|       |    /// - parameter options: Scanning options same as  CoreBluetooth  central manager option.
   23|       |    /// - returns: A publisher with stream of disovered peripherals.
   24|     11|    public func startDiscovery(for littleBluetooth: LittleBlueTooth, withServices services: [CBUUID]?, options: [String : Any]? = nil) -> AnyPublisher<PeripheralDiscovery, LittleBluetoothError> {
   25|     11|        func startDiscovery<Upstream: Publisher>(upstream: Upstream,
   26|     11|                                                 for littleBluetooth: LittleBlueTooth,
   27|     11|                                                 withServices services: [CBUUID]?,
   28|     11|                                                 options: [String : Any]? = nil) -> AnyPublisher<PeripheralDiscovery, LittleBluetoothError> where Upstream.Failure == LittleBluetoothError {
   29|     11|            return upstream
   30|     11|                .flatMapLatest { _ in
   31|     11|                    littleBluetooth.startDiscovery(withServices: services, options: options)
   32|     11|            }
   33|     11|        }
   34|     11|        return startDiscovery(upstream: self,
   35|     11|                              for: littleBluetooth,
   36|     11|                              withServices: services,
   37|     11|                              options: options)
   38|     11|    }
   39|       |    
   40|       |    /// Stops peripheral discovery
   41|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   42|       |    /// - returns: A publisher when discovery has been stopped
   43|      1|    public func stopDiscovery(for littleBluetooth: LittleBlueTooth) -> AnyPublisher<Void, LittleBluetoothError> {
   44|      1|        func stopDiscovery<Upstream: Publisher>(upstream: Upstream,
   45|      1|                                                for littleBluetooth: LittleBlueTooth) -> AnyPublisher<Void, LittleBluetoothError>where  Upstream.Failure == LittleBluetoothError {
   46|      1|            return upstream
   47|      2|            .flatMapLatest { _ in
   48|      2|                littleBluetooth.stopDiscovery()
   49|      2|            }
   50|      1|        }
   51|      1|        return stopDiscovery(upstream: self,
   52|      1|                                 for: littleBluetooth)
   53|      1|    }
   54|       |}
   55|       |
   56|       |// MARK: - Connect
   57|       |extension Publisher where Self.Output == PeripheralDiscovery, Self.Failure == LittleBluetoothError {
   58|       |        
   59|       |    /// Starts connection for `PeripheralDiscovery`
   60|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   61|       |    /// - parameter options: Connecting options same as  CoreBluetooth  central manager option.
   62|       |    /// - returns: A publisher with the just connected `Peripheral`.
   63|       |    public func connect(for littleBluetooth: LittleBlueTooth,
   64|      9|                 options: [String : Any]? = nil) -> AnyPublisher<Peripheral, LittleBluetoothError> {
   65|      9|        
   66|      9|        func connect<Upstream: Publisher>(upstream: Upstream,
   67|      9|                                          for littleBluetooth: LittleBlueTooth,
   68|      9|                                          options: [String : Any]? = nil) -> AnyPublisher<Peripheral, LittleBluetoothError> where Upstream.Output == PeripheralDiscovery, Upstream.Failure == LittleBluetoothError {
   69|      9|            return upstream
   70|      9|            .flatMapLatest { (periph) in
   71|      9|                littleBluetooth.connect(to: periph, options: options)
   72|      9|            }.eraseToAnyPublisher()
   73|      9|        }
   74|      9|        
   75|      9|        return connect(upstream: self,
   76|      9|                       for: littleBluetooth,
   77|      9|                       options: options)
   78|      9|    }
   79|       |}
   80|       |
   81|       |extension Publisher where Self.Output == PeripheralIdentifier, Self.Failure == LittleBluetoothError {
   82|       |    
   83|       |    /// Starts connection for `PeripheralIdentifier`
   84|       |    /// - parameter littleBluetooth: the `LittleBlueTooth` instance
   85|       |    /// - parameter options: Connecting options same as  CoreBluetooth  central manager option.
   86|       |    /// - returns: A publisher with the just connected `Peripheral`.
   87|       |    public func connect(for littleBluetooth: LittleBlueTooth,
   88|      1|                 options: [String : Any]? = nil) -> AnyPublisher<Peripheral, LittleBluetoothError> {
   89|      1|        
   90|      1|        func connect<Upstream: Publisher>(upstream: Upstream,
   91|      1|                                          for littleBluetooth: LittleBlueTooth,
   92|      1|                                          options: [String : Any]? = nil) -> AnyPublisher<Peripheral, LittleBluetoothError> where Upstream.Output == PeripheralIdentifier, Upstream.Failure == LittleBluetoothError {
   93|      1|            return upstream
   94|      1|            .flatMapLatest { (periph) in
   95|      1|                littleBluetooth.connect(to: periph, options: options)
   96|      1|            }.eraseToAnyPublisher()
   97|      1|        }
   98|      1|        
   99|      1|        return connect(upstream: self,
  100|      1|                       for: littleBluetooth,
  101|      1|                       options: options)
  102|      1|    }
  103|       |}
  104|       |
  105|       |// MARK: - Disconnect
  106|       |extension Publisher where Self.Failure == LittleBluetoothError {
  107|       |    
  108|       |    /// Disconnect the connected `Peripheral`
  109|       |    /// - returns: A publisher with the just disconnected `Peripheral` or a `LittleBluetoothError`
  110|       |    @discardableResult
  111|      1|    public func disconnect(for littleBluetooth: LittleBlueTooth) -> AnyPublisher<Peripheral, LittleBluetoothError> {
  112|      1|        func disconnect<Upstream: Publisher>(upstream: Upstream,
  113|      1|                                             for littleBluetooth: LittleBlueTooth) -> AnyPublisher<Peripheral, LittleBluetoothError> where  Upstream.Failure == LittleBluetoothError {
  114|      1|            return upstream
  115|      1|            .flatMapLatest { _ in
  116|      1|                littleBluetooth.disconnect()
  117|      1|            }
  118|      1|        }
  119|      1|        return disconnect(upstream: self,
  120|      1|                          for: littleBluetooth)
  121|      1|    }
  122|       |
  123|       |    /// Specialized timeout function to return a `LittleBluetoothError` error type. By default it returns `.operationTimeout`, but you can specify a different error such as `.connectionTimeout`,  `.scanTimeout`
  124|       |    /// Terminates publishing if the upstream publisher exceeds the specified time interval without producing an element.
  125|       |    /// - Parameters:
  126|       |    ///   - interval: The maximum time interval the publisher can go without emitting an element, expressed in the time system of the scheduler.
  127|       |    ///   - scheduler: The scheduler to deliver events on.
  128|       |    ///   - options: Scheduler options that customize the delivery of elements.
  129|       |    ///   - error: An error to be returned if the publisher times out, by default `LittleBluetoothError.connectionTimeout`
  130|       |    /// - Returns: A publisher that terminates if the specified interval elapses with no events received from the upstream publisher.
  131|      1|    public func timeout<S>(_ interval: S.SchedulerTimeType.Stride, scheduler: S, options: S.SchedulerOptions? = nil, error: LittleBluetoothError = .operationTimeout) -> AnyPublisher<Self.Output, LittleBluetoothError> where S: Scheduler {
  132|      1|        func timeout<Upstream: Publisher, S>(upsstream: Upstream,_ interval: S.SchedulerTimeType.Stride, scheduler: S, options: S.SchedulerOptions? = nil, error: LittleBluetoothError = .operationTimeout) -> AnyPublisher<Upstream.Output, LittleBluetoothError> where S: Scheduler, Upstream.Failure == LittleBluetoothError {
  133|      1|            return upsstream
  134|      1|                .timeout(interval, scheduler: scheduler, options: options, customError: {error})
  135|      1|                .eraseToAnyPublisher()
  136|      1|        }
  137|      1|        
  138|      1|        return timeout(upsstream: self, interval, scheduler: scheduler, options: options, error: error)
  139|      1|    }
  140|       |    
  141|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Extension/Helper.swift:
    1|       |//
    2|       |//  Helper.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 09/08/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Combine
   10|       |import os.log
   11|       |#if TEST
   12|       |import CoreBluetoothMock
   13|       |#else
   14|       |import CoreBluetooth
   15|       |#endif
   16|       |
   17|       |extension AnyCancellable {
   18|       |  func store(in dictionary: inout [UUID : AnyCancellable],
   19|    235|             for key: UUID) {
   20|    235|    dictionary[key] = self
   21|    235|  }
   22|       |}
   23|       |extension Publisher {
   24|       |
   25|    174|   func flatMapLatest<T: Publisher>(_ transform: @escaping (Self.Output) -> T) -> AnyPublisher<T.Output, T.Failure> where T.Failure == Self.Failure {
   26|    174|       return map(transform).switchToLatest().eraseToAnyPublisher()
   27|    174|   }
   28|       |}
   29|       |
   30|       |extension TimeInterval {
   31|      1|    public var dispatchInterval: DispatchTimeInterval {
   32|      1|        let microseconds = Int64(self * TimeInterval(USEC_PER_SEC)) // perhaps use nanoseconds, though would more often be > Int.max
   33|      1|        return microseconds < Int.max ? DispatchTimeInterval.microseconds(Int(microseconds)) : DispatchTimeInterval.seconds(Int(self))
   34|      1|    }
   35|       |}
   36|       |
   37|       |extension OSLog {
   38|       |    public static var Subsystem = "it.vanillagorilla.LittleBlueTooth"
   39|       |    public static var General = "General"
   40|       |    public static var CentralManager = "CentralManager"
   41|       |    public static var Peripheral = "Peripheral"
   42|       |    public static var Restore = "Restore"
   43|       |
   44|       |    public static let LittleBT_Log_General = OSLog(subsystem: Subsystem, category: General)
   45|       |    public static let LittleBT_Log_CentralManager = OSLog(subsystem: Subsystem, category: CentralManager)
   46|       |    public static let LittleBT_Log_Peripheral = OSLog(subsystem: Subsystem, category: Peripheral)
   47|       |    public static let LittleBT_Log_Restore = OSLog(subsystem: Subsystem, category: Restore)
   48|       |
   49|       |}
   50|       |#if TEST
   51|       |extension CBMPeripheral {
   52|    109|    public var description: String {
   53|    109|        return "Test peripheral"
   54|    109|    }
   55|       |}
   56|       |#endif

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/AdvertisingData.swift:
    1|       |//
    2|       |//  AdvertisingData.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |#if TEST
   11|       |import CoreBluetoothMock
   12|       |#else
   13|       |import CoreBluetooth
   14|       |#endif
   15|       |
   16|       |public struct AdvertisingInfo {
   17|       |     public let advertisementData: [String: Any]
   18|       |
   19|       |       /// Creates advertisement data based on CoreBluetooth's dictionary
   20|       |       /// - parameter advertisementData: Core Bluetooth's advertisement data
   21|     42|       public init(advertisementData: [String: Any]) {
   22|     42|           self.advertisementData = advertisementData
   23|     42|       }
   24|       |
   25|       |       /// A string containing the local name of a peripheral.
   26|     19|       public var localName: String? {
   27|     19|           return advertisementData[CBAdvertisementDataLocalNameKey] as? String
   28|     19|       }
   29|       |
   30|       |       /// A Data object containing the manufacturer data of a peripheral.
   31|     19|       public var manufacturerData: Data? {
   32|     19|           return advertisementData[CBAdvertisementDataManufacturerDataKey] as? Data
   33|     19|       }
   34|       |
   35|       |       /// A dictionary containing service-specific advertisement data.
   36|       |       /// The keys are CBUUID objects, representing CBService UUIDs. The values are Data objects,
   37|       |       /// representing service-specific data.
   38|     19|       public var serviceData: [CBUUID: Data]? {
   39|     19|           return advertisementData[CBAdvertisementDataServiceDataKey] as? [CBUUID: Data]
   40|     19|       }
   41|       |
   42|       |       /// An array of service UUIDs.
   43|     19|       public var serviceUUIDs: [CBUUID]? {
   44|     19|           return advertisementData[CBAdvertisementDataServiceUUIDsKey] as? [CBUUID]
   45|     19|       }
   46|       |
   47|       |       /// An array of one or more CBUUID objects, representing CBService UUIDs that were found in the “overflow”
   48|       |       /// area of the advertisement data.
   49|     19|       public var overflowServiceUUIDs: [CBUUID]? {
   50|     19|           return advertisementData[CBAdvertisementDataOverflowServiceUUIDsKey] as? [CBUUID]
   51|     19|       }
   52|       |
   53|       |       /// A number (an instance of NSNumber) containing the transmit power of a peripheral.
   54|       |       /// This key and value are available if the broadcaster (peripheral)
   55|       |       /// provides its Tx power level in its advertising packet.
   56|       |       /// Using the RSSI value and the Tx power level, it is possible to calculate path loss.
   57|     19|       public var txPowerLevel: NSNumber? {
   58|     19|           return advertisementData[CBAdvertisementDataTxPowerLevelKey] as? NSNumber
   59|     19|       }
   60|       |
   61|       |       /// A Boolean value that indicates whether the advertising event type is connectable.
   62|       |       /// The value for this key is an NSNumber object. You can use this value to determine whether
   63|       |       /// a peripheral is connectable at a particular moment.
   64|     19|       public var isConnectable: Bool? {
   65|     19|           return advertisementData[CBAdvertisementDataIsConnectable] as? Bool
   66|     19|       }
   67|       |
   68|       |       /// An array of one or more CBUUID objects, representing CBService UUIDs.
   69|     19|       public var solicitedServiceUUIDs: [CBUUID]? {
   70|     19|           return advertisementData[CBAdvertisementDataSolicitedServiceUUIDsKey] as? [CBUUID]
   71|     19|       }
   72|       |}
   73|       |
   74|       |extension AdvertisingInfo: CustomDebugStringConvertible {
   75|       |    
   76|     19|    public var debugDescription: String {
   77|     19|        return """
   78|     19|        Name: \(localName ?? "Not available")
   79|     19|        Manufacturer: \(manufacturerData?.description ?? "Not available")
   80|     19|        Service Data: \(serviceData ?? [:])
   81|     19|        ServiceUUID: \(serviceUUIDs ?? [])
   82|     19|        OverflowService: \(overflowServiceUUIDs ?? [])
   83|     19|        TX: \(txPowerLevel?.stringValue ?? "Not available")
   84|     19|        Connectable: \(isConnectable?.description ?? "Not available")
   85|     19|        SolicitedService: \(solicitedServiceUUIDs ?? [])
   86|     19|        """
   87|     19|    }
   88|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/CentralRestorer.swift:
    1|       |//
    2|       |//  CentralRestorer.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 15/07/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import Combine
   10|       |#if TEST
   11|       |import CoreBluetoothMock
   12|       |#else
   13|       |import CoreBluetooth
   14|       |#endif
   15|       |/**
   16|       | This object contains parsed information passed from the `centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any])` method of `CBCentralManagerDelegate` dictionary
   17|       | */
   18|       |public struct CentralRestorer {
   19|       |    public unowned let centralManager: CBCentralManager
   20|       |    public let restoredInfo: [String : Any]
   21|       |    
   22|       |
   23|       |    /// Array of `PeripheralIdentifier` objects which have been restored.
   24|       |    /// These are peripherals that were connected to the central manager (or had a connection pending)
   25|       |    /// at the time the app was terminated by the system.
   26|      3|    public var peripherals: [PeripheralIdentifier] {
   27|      3|        if let peripherals = restoredInfo[CBCentralManagerRestoredStatePeripheralsKey] as? [CBPeripheral] {
   28|      3|            return centralManager.retrievePeripherals(withIdentifiers: peripherals.map{$0.identifier}).map {PeripheralIdentifier(peripheral: $0)}
   29|      3|        }
   30|      0|        return []
   31|      3|    }
   32|       |    
   33|       |    /// Dictionary that contains all of the peripheral scan options that were being used
   34|       |    /// by the central manager at the time the app was terminated by the system.
   35|      2|    public var scanOptions: [String: AnyObject] {
   36|      2|        if let info = restoredInfo[CBCentralManagerRestoredStateScanOptionsKey] as? [String: AnyObject] {
   37|      2|            return info
   38|      2|        }
   39|      0|        return [:]
   40|      2|      }
   41|       |
   42|       |      /// Array of `CBUUID` objects of services which have been restored.
   43|       |      /// These are all the services the central manager was scanning for at the time the app
   44|       |      /// was terminated by the system.
   45|      2|      public var services: [CBUUID] {
   46|      2|        if let servicesUUID = restoredInfo[CBCentralManagerRestoredStateScanServicesKey] as? [CBUUID] {
   47|      2|            return servicesUUID
   48|      2|        }
   49|      0|        return []
   50|      2|      }
   51|       |}
   52|       |
   53|       |extension CentralRestorer: CustomDebugStringConvertible {
   54|      1|    public var debugDescription: String {
   55|      1|        return """
   56|      1|        Peripherals: \(peripherals)
   57|      1|        Scan options: \(scanOptions)
   58|      1|        Services: \(services)
   59|      1|        """
   60|      1|    }
   61|       |}
   62|       |
   63|       |/**
   64|       |This object contains the restored action during state restoration
   65|       |*/
   66|       |public enum Restored: CustomDebugStringConvertible {
   67|       |    /// Peripherals scan has been restored
   68|       |    case scan(discoveryPublisher: AnyPublisher<PeripheralDiscovery, LittleBluetoothError>)
   69|       |    /// Peripheral has been restored
   70|       |    case peripheral(Peripheral)
   71|       |    /// Nothing has been restored
   72|       |    case nothing
   73|       |    
   74|      1|    public var debugDescription: String {
   75|      1|        switch self {
   76|      1|        case .scan(_):
   77|      0|            return "Restored Scan"
   78|      1|        case .peripheral(let periph):
   79|      0|            return "Restored \(periph.debugDescription)"
   80|      1|        case .nothing:
   81|      1|            return "Nothing to be restored"
   82|      1|        }
   83|      1|    }
   84|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/LittleBlueToothCharacteristic.swift:
    1|       |//
    2|       |//  Task.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |#if TEST
   11|       |import CoreBluetoothMock
   12|       |#else
   13|       |import CoreBluetooth
   14|       |#endif
   15|       |
   16|       |public typealias LittleBlueToothServiceIndentifier = String
   17|       |public typealias LittleBlueToothCharacteristicIndentifier = String
   18|       |
   19|       |
   20|       |/// A representation of a bluetooth characteristic
   21|       |public struct LittleBlueToothCharacteristic: Identifiable {
   22|       |    public let id: CBUUID
   23|       |    public let service: CBUUID
   24|       |    public let properties: Properties
   25|       |    
   26|     82|    public var rawValue: Data? {
   27|     82|        cbCharacteristic?.value
   28|     82|    }
   29|       |    
   30|       |    private var cbCharacteristic: CBCharacteristic?
   31|       |    
   32|     30|    public init(characteristic: LittleBlueToothCharacteristicIndentifier, for service: LittleBlueToothServiceIndentifier, properties: LittleBlueToothCharacteristic.Properties) {
   33|     30|        self.id = CBUUID(string: characteristic)
   34|     30|        self.service = CBUUID(string: service)
   35|     30|        self.properties = properties
   36|     30|    }
   37|       |    
   38|    175|    public init(with characteristic: CBCharacteristic) {
   39|    175|        self.id = characteristic.uuid
   40|    175|        self.service = characteristic.service.uuid
   41|    175|        self.cbCharacteristic = characteristic
   42|    175|        self.properties = Properties(properties: characteristic.properties)
   43|    175|    }
   44|       |    
   45|     82|    public func value<T: Readable>() throws -> T {
   46|     82|        guard let data = rawValue else {
   47|      0|            throw LittleBluetoothError.emptyData
   48|     82|        }
   49|     82|        return try T.init(from: data)
   50|     82|    }
   51|       |}
   52|       |
   53|       |extension LittleBlueToothCharacteristic: Equatable, Hashable {
   54|      2|    public static func == (lhs: Self, rhs: Self) -> Bool {
   55|      2|        if lhs.id == rhs.id &&
   56|      2|            lhs.service == rhs.service {
   57|      1|            return true
   58|      1|        }
   59|      1|        return false
   60|      2|    }
   61|       |    
   62|      2|    public func hash(into hasher: inout Hasher) {
   63|      2|        hasher.combine(id)
   64|      2|        hasher.combine(service)
   65|      2|    }
   66|       |    
   67|       |}
   68|       |
   69|       |public extension LittleBlueToothCharacteristic {
   70|       |    /// Permitted operations on the characteristic they already exist in CBCharacteristic need to remap when initialized from CBCharacteristic
   71|       |    struct Properties: OptionSet {
   72|       |        public let rawValue: UInt8
   73|       |        
   74|       |        public static var broadcast                     = Properties(rawValue: 1 << 0)
   75|       |        public static var read                          = Properties(rawValue: 1 << 1)
   76|       |        public static var writeWithoutResponse          = Properties(rawValue: 1 << 2)
   77|       |        public static var write                         = Properties(rawValue: 1 << 3)
   78|       |        public static var notify                        = Properties(rawValue: 1 << 4)
   79|       |        public static var indicate                      = Properties(rawValue: 1 << 5)
   80|       |        public static var authenticatedSignedWrites     = Properties(rawValue: 1 << 6)
   81|       |        public static var extendedProperties            = Properties(rawValue: 1 << 7)
   82|       |        public static var notifyEncryptionRequired      = Properties(rawValue: 1 << 8)
   83|       |        public static var indicateEncryptionRequired    = Properties(rawValue: 1 << 9)
   84|       |        
   85|  2.33k|        public init(rawValue: UInt8) {
   86|  2.33k|            self.rawValue = rawValue
   87|  2.33k|        }
   88|       |        
   89|    175|        public init(properties: CBCharacteristicProperties) {
   90|    175|            self = Self.mapToProperties(values: properties)
   91|    175|        }
   92|       |        
   93|    175|        static func mapToProperties(values: CBCharacteristicProperties) -> Properties {
   94|    175|            var properties: Properties = []
   95|    474|            values.elements().forEach { (prop) in
   96|    474|                switch prop {
   97|    474|                case .broadcast:
   98|      0|                    properties.update(with: .broadcast)
   99|    474|                case .read:
  100|    175|                    properties.update(with: .read)
  101|    474|                case .writeWithoutResponse:
  102|      0|                    properties.update(with: .writeWithoutResponse)
  103|    474|                case .write:
  104|    124|                    properties.update(with: .write)
  105|    474|                case .notify:
  106|    175|                    properties.update(with: .notify)
  107|    474|                case .indicate:
  108|      0|                    properties.update(with: .indicate)
  109|    474|                case .authenticatedSignedWrites:
  110|      0|                    properties.update(with: .authenticatedSignedWrites)
  111|    474|                case .extendedProperties:
  112|      0|                    properties.update(with: .extendedProperties)
  113|    474|                case .notifyEncryptionRequired:
  114|      0|                    properties.update(with: .notifyEncryptionRequired)
  115|    474|                case .indicateEncryptionRequired:
  116|      0|                    properties.update(with: .indicateEncryptionRequired)
  117|    474|                default:
  118|      0|                    print("NO mapping")
  119|    474|                }
  120|    474|            }
  121|    175|            return properties
  122|    175|        }
  123|       |    }
  124|       |}
  125|       |

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/LittleBluetoothConfiguration.swift:
    1|       |//
    2|       |//  LittleBluetoothConfiguration.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 26/07/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |
   10|       |/// Pass a `Peripheral` and an evetual `LittleBluetoothError` and expect a boolean as an answer
   11|       |public typealias AutoconnectionHandler = (PeripheralIdentifier, LittleBluetoothError?) -> Bool
   12|       |
   13|       |/// Configuration object that must be passed during the `LittleBlueTooth` initialization
   14|       |public struct LittleBluetoothConfiguration {
   15|       |    /// `CBCentralManager` options dictionary for instance the restore identifier, thay are the same
   16|       |    /// requested for `CBCentralManager`
   17|       |    public var centralManagerOptions: [String : Any]?
   18|       |    /// `CBCentralManager` queue
   19|       |    public var centralManagerQueue: DispatchQueue?
   20|       |    /// This handler must be used to handle connection process after a disconnession.
   21|       |    /// You can inspect the error and decide if an automatic connection is necessary.
   22|       |    /// If you return `true` the connection process will start, once the peripheral has been found a connection will be established.
   23|       |    /// If you return `false` the system will not try to establish a connection
   24|       |    /// Connection process will remain active also in background if the app has the right
   25|       |    /// permission, to cancel just call `disconnect`.
   26|       |    /// When a connection will be established an `.autoConnected(PeripheralIdentifier)` event will be streamed to
   27|       |    /// the `connectionEventPublisher`
   28|       |    public var autoconnectionHandler: AutoconnectionHandler?
   29|       |    /// Handler used to manage state restoration. `Restored` object will contain the restored information
   30|       |    /// could be a peripheral, a scan or nothing
   31|       |    public var restoreHandler: ((Restored) -> Void)?
   32|       |    /// Enable logging, log is made using os_log and it exposes some information even in release configuration
   33|       |    public var isLogEnabled = false
   34|       |    
   35|     45|    public init() {}
   36|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/Loggable.swift:
    1|       |//
    2|       |//  Loggable.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 07/08/2020.
    6|       |//
    7|       |
    8|       |import Foundation
    9|       |import os.log
   10|       |
   11|       |protocol Loggable {
   12|       |    var isLogEnabled: Bool {get set}
   13|       |    func log(_ message: StaticString, log: OSLog, type: OSLogType, arg: CVarArg...)
   14|       |}
   15|       |
   16|       |
   17|       |extension Loggable  {
   18|  1.22k|    func log(_ message: StaticString, log: OSLog, type: OSLogType, arg: CVarArg...) {
   19|  1.22k|        #if !TEST
   20|  1.22k|        guard isLogEnabled else {
   21|  1.22k|            return
   22|  1.22k|        }
   23|  1.22k|        os_log(type, log: log, message, arg)
   24|  1.22k|        #endif
   25|  1.22k|    }
   26|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/Peripheral.swift:
    1|       |//
    2|       |//  Peripheral.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Combine
   11|       |
   12|       |#if TEST
   13|       |import CoreBluetoothMock
   14|       |#else
   15|       |import CoreBluetooth
   16|       |#endif
   17|       |
   18|       |public enum PeripheralChanges {
   19|       |    case name(String?)
   20|       |    case invalidatedServices([CBService])
   21|       |}
   22|       |
   23|       |public enum PeripheralState {
   24|       |    case disconnected
   25|       |    case connecting
   26|       |    case connected
   27|       |    case disconnecting
   28|       |    case unknown
   29|       |    
   30|  1.50k|    init(state: CBPeripheralState) {
   31|  1.50k|        switch state {
   32|  1.50k|        case .disconnected:
   33|  1.35k|            self = .disconnected
   34|  1.50k|        case .connected:
   35|    146|            self = .connected
   36|  1.50k|        case .disconnecting:
   37|      1|            self = .disconnecting
   38|  1.50k|        case .connecting:
   39|      0|            self = .connecting
   40|  1.50k|        default:
   41|      0|            self = .unknown
   42|  1.50k|        }
   43|  1.50k|    }
   44|       |}
   45|       |
   46|       |public class Peripheral: Identifiable {
   47|     18|    public var id: UUID {
   48|     18|        cbPeripheral.identifier
   49|     18|    }
   50|       |    
   51|     18|    public var name: String? {
   52|     18|        cbPeripheral.name
   53|     18|    }
   54|       |    
   55|     69|    public var state: PeripheralState {
   56|     69|        PeripheralState(state: cbPeripheral.state)
   57|     69|    }
   58|       |    
   59|       |    public let cbPeripheral: CBPeripheral
   60|       |    public var rssi: Int?
   61|       |    
   62|       |
   63|       |    var isLogEnabled: Bool {
   64|     68|        get {
   65|     68|            return _isLogEnabled
   66|     68|        }
   67|     71|        set {
   68|     71|            _isLogEnabled = newValue
   69|     71|            peripheralProxy.isLogEnabled = newValue
   70|     71|        }
   71|       |    }
   72|       |    
   73|       |    lazy var changesPublisher: AnyPublisher<PeripheralChanges, Never> =
   74|       |               peripheralProxy.peripheralChangesPublisher
   75|       |               .share()
   76|       |               .eraseToAnyPublisher()
   77|       |    
   78|       |    lazy var listenPublisher: AnyPublisher<CBCharacteristic, LittleBluetoothError> =
   79|       |            peripheralProxy.peripheralUpdatedValueForNotifyCharacteristicPublisher
   80|    122|            .tryMap { (value) -> CBCharacteristic in
   81|    122|                switch value {
   82|    122|                case let (_, error?):
   83|      0|                    throw error
   84|    122|                case let (charact, _):
   85|    122|                    return charact
   86|    122|                }
   87|    122|            }
   88|      0|            .mapError {$0 as! LittleBluetoothError}
   89|       |            .share()
   90|       |            .eraseToAnyPublisher()
   91|       |    
   92|       |    let peripheralStatePublisher: AnyPublisher<PeripheralState, Never>
   93|       |    
   94|     36|    private let peripheralProxy = CBPeripheralDelegateProxy()
   95|       |    private var _isLogEnabled: Bool = false
   96|       |
   97|     36|    init(_ peripheral: CBPeripheral) {
   98|     36|        self.cbPeripheral = peripheral
   99|     36|        self.cbPeripheral.delegate = self.peripheralProxy
  100|     36|        #if !TEST
  101|     36|        self.peripheralStatePublisher = self.cbPeripheral.publisher(for: \.state)
  102|     36|            .map{ (state) -> PeripheralState in
  103|     36|                PeripheralState(state: state)
  104|     36|            }
  105|     36|            .share()
  106|     36|            .eraseToAnyPublisher()
  107|     36|        // Using a timer to poll peripheral state for test to simulate KVO
  108|     36|        #else
  109|     36|        self.peripheralStatePublisher = Timer.publish(every: 0.2, on: .main, in: .common)
  110|     36|        .autoconnect()
  111|  1.43k|        .map {_ in
  112|  1.43k|            PeripheralState(state: peripheral.state)
  113|  1.43k|        }
  114|     36|        .eraseToAnyPublisher()
  115|     36|        #endif
  116|     36|    }
  117|       |    
  118|     34|    fileprivate func getService(serviceUUID: CBUUID) -> AnyPublisher<[CBService]?, LittleBluetoothError> {
  119|     34|        if let services = self.cbPeripheral.services, services.contains(where: { (service) -> Bool in
  120|     13|            return service.uuid == serviceUUID
  121|     13|        }) {
  122|     13|            return Result<[CBService]?, LittleBluetoothError>.Publisher(.success(services)).eraseToAnyPublisher()
  123|     21|        } else {
  124|     21|            let services = self.peripheralProxy.peripheralDiscoveredServicesPublisher
  125|     21|            .tryMap { (value) -> [CBService]? in
  126|     20|                switch value {
  127|     20|                case let (_, error?):
  128|      0|                    throw error
  129|     20|                case let (services?, _) where services.map{$0.uuid}.contains(serviceUUID):
  130|     19|                    return services
  131|     20|                case (_, .none):
  132|      1|                    throw LittleBluetoothError.serviceNotFound(nil)
  133|     20|                }
  134|     20|            }
  135|     21|            .mapError {$0 as! LittleBluetoothError}
  136|     21|            defer {
  137|     21|                self.cbPeripheral.discoverServices([serviceUUID])
  138|     21|            }
  139|     21|            return services.eraseToAnyPublisher()
  140|     21|        }
  141|      0|    }
  142|       |    
  143|     32|    fileprivate func getCharateristic(characteristicUUID: CBUUID, from service: CBService) -> AnyPublisher<CBService, LittleBluetoothError> {
  144|     32|        if let characteristics = service.characteristics, characteristics.contains(where: { (charact) -> Bool in
  145|     15|            return charact.uuid == characteristicUUID
  146|     15|        }) {
  147|     10|            return Result<CBService, LittleBluetoothError>.Publisher(.success(service)).eraseToAnyPublisher()
  148|     22|        } else {
  149|     22|            let charact = self.peripheralProxy.peripheralDiscoveredCharacteristicsForServicePublisher
  150|     22|            .tryMap { (value) -> CBService in
  151|     22|                switch value {
  152|     22|                case let (_, error?):
  153|      0|                    throw error
  154|     22|                case let (service, _):
  155|     22|                    return service
  156|     22|                }
  157|     22|            }
  158|     22|            .mapError {$0 as! LittleBluetoothError}
  159|     22|            defer {
  160|     22|                self.cbPeripheral.discoverCharacteristics([characteristicUUID], for: service)
  161|     22|            }
  162|     22|            return charact.eraseToAnyPublisher()
  163|     22|        }
  164|      0|    }
  165|       |    
  166|     34|    fileprivate func discoverCharacteristic(_ charateristicUUID: CBUUID, fromService serviceUUID: CBUUID) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> {
  167|     34|        let discovery = self.getService(serviceUUID: serviceUUID)
  168|     34|        .customPrint("[LBT] Discover service", isEnabled: isLogEnabled)
  169|     34|        .flatMap { services -> AnyPublisher<CBService, LittleBluetoothError> in
  170|     32|                let service = services!.filter{ $0.uuid == serviceUUID}.first!
  171|     32|                return self.getCharateristic(characteristicUUID: charateristicUUID, from: service)
  172|     32|        }
  173|     34|        .customPrint("[LBT] Discover characteristic", isEnabled: isLogEnabled)
  174|     34|        .tryMap { (service) -> CBCharacteristic in
  175|     37|            guard let charact = service.characteristics?.filter({ $0.uuid == charateristicUUID}).first else {
  176|      2|                throw LittleBluetoothError.characteristicNotFound(nil)
  177|     30|            }
  178|     30|            return charact
  179|     32|        }
  180|     34|        .mapError{$0 as! LittleBluetoothError}
  181|     34|        .eraseToAnyPublisher()
  182|     34|        return discovery
  183|     34|    }
  184|       |    
  185|      2|    func readRSSI() -> AnyPublisher<Int, LittleBluetoothError> {
  186|      2|        let readRSSI =
  187|      2|            peripheralProxy.peripheralRSSIPublisher
  188|      2|            .tryMap { (value) -> Int in
  189|      2|                switch value {
  190|      2|                case let (_, error?):
  191|      0|                    throw error
  192|      2|                case let (rssi, _):
  193|      2|                    return rssi
  194|      2|                }
  195|      2|            }
  196|      2|            .mapError {$0 as! LittleBluetoothError}
  197|      2|            .eraseToAnyPublisher()
  198|      2|        defer {
  199|      2|            cbPeripheral.readRSSI()
  200|      2|        }
  201|      2|        return readRSSI
  202|      2|    }
  203|       |    
  204|     12|    func read(from charateristicUUID: CBUUID, of serviceUUID: CBUUID) -> AnyPublisher<Data?, LittleBluetoothError> {
  205|     12|        let read = discoverCharacteristic(charateristicUUID, fromService: serviceUUID)
  206|     12|        .flatMap { characteristic -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  207|      8|            self.cbPeripheral.readValue(for: characteristic)
  208|      8|            return self.peripheralProxy.peripheralUpdatedValueForCharacteristicPublisher
  209|      8|            .tryMap { (value) -> CBCharacteristic in
  210|      8|                switch value {
  211|      8|                case let (_, error?):
  212|      0|                    throw error
  213|      8|                case let (charact, _):
  214|      8|                    return charact
  215|      8|                }
  216|      8|            }
  217|      8|            .mapError {$0 as! LittleBluetoothError}
  218|      8|            .eraseToAnyPublisher()
  219|      8|        }
  220|     12|        .map { (characteristic) -> Data? in
  221|      8|            characteristic.value
  222|      8|        }
  223|     12|        .eraseToAnyPublisher()
  224|     12|        return read
  225|     12|    }
  226|       |    
  227|       |    
  228|      6|    func write(to charateristicUUID: CBUUID, of serviceUUID: CBUUID, data: Data, response: Bool = true) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> {
  229|      6|        let write = discoverCharacteristic(charateristicUUID, fromService: serviceUUID)
  230|      6|        .flatMap { characteristic -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  231|      6|            if response {
  232|      4|                self.cbPeripheral.writeValue(data, for: characteristic, type: .withResponse)
  233|      4|                return self.peripheralProxy.peripheralWrittenValueForCharacteristicPublisher.tryMap { (value) -> CBCharacteristic in
  234|      4|                    switch value {
  235|      4|                    case let (_, error?):
  236|      0|                        throw error
  237|      4|                    case let (charact, _):
  238|      4|                        return charact
  239|      4|                    }
  240|      4|                }
  241|      4|                .mapError {$0 as! LittleBluetoothError}
  242|      4|                .eraseToAnyPublisher()
  243|      4|            } else {
  244|      2|                
  245|      2|                let writeWOResp = self.peripheralProxy.peripheralIsReadyToSendWriteWithoutResponse
  246|      2|                .map { _ -> Bool in
  247|      0|                    return true
  248|      0|                }
  249|      2|                .prepend([self.cbPeripheral.canSendWriteWithoutResponse])
  250|      2|                .filter{ $0 }
  251|      2|                .prefix(1)
  252|      2|                .map {_ in
  253|      2|                    self.cbPeripheral.writeValue(data, for: characteristic, type: .withoutResponse)
  254|      2|                }
  255|      2|                .setFailureType(to: LittleBluetoothError.self)
  256|      2|                .map { characteristic }
  257|      2|                .eraseToAnyPublisher()
  258|      2|                
  259|      2|                return writeWOResp
  260|      2|            }
  261|      0|        }
  262|      6|        .eraseToAnyPublisher()
  263|      6|        return write
  264|      6|    }
  265|       |
  266|       |    
  267|     10|    func startListen(from charateristicUUID: CBUUID, of serviceUUID: CBUUID) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> {
  268|     10|        let notifyStart = discoverCharacteristic(charateristicUUID, fromService: serviceUUID)
  269|     10|        .flatMap { (characteristic) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  270|     10|            if characteristic.isNotifying {
  271|      0|               return Result<CBCharacteristic, LittleBluetoothError>.Publisher(.success(characteristic)).eraseToAnyPublisher()
  272|     10|            }
  273|     10|            defer {
  274|     10|                self.cbPeripheral.setNotifyValue(true, for: characteristic)
  275|     10|            }
  276|     10|            return self.peripheralProxy.peripheralUpdatedNotificationStateForCharacteristicPublisher
  277|     10|            .tryMap { (value) -> CBCharacteristic in
  278|     10|                switch value {
  279|     10|                case let (_, error?):
  280|      0|                    throw error
  281|     10|                case let (charact, _):
  282|     10|                    return charact
  283|     10|                }
  284|     10|            }
  285|     10|            .mapError {$0 as! LittleBluetoothError}
  286|     10|            .eraseToAnyPublisher()
  287|     10|        }
  288|     10|        .eraseToAnyPublisher()
  289|     10|        return notifyStart
  290|     10|    }
  291|       |    
  292|      6|    func stopListen(from charateristicUUID: CBUUID, of serviceUUID: CBUUID) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> {
  293|      6|        let notifyStop = discoverCharacteristic(charateristicUUID, fromService: serviceUUID)
  294|      6|        .flatMap { (characteristic) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  295|      6|            if !characteristic.isNotifying {
  296|      0|               return Result<CBCharacteristic, LittleBluetoothError>.Publisher(.success(characteristic)).eraseToAnyPublisher()
  297|      6|            }
  298|      6|            defer {
  299|      6|                self.cbPeripheral.setNotifyValue(false, for: characteristic)
  300|      6|            }
  301|      6|            return self.peripheralProxy.peripheralUpdatedNotificationStateForCharacteristicPublisher
  302|      6|            .tryMap { (value) -> CBCharacteristic in
  303|      6|                switch value {
  304|      6|                case let (_, error?):
  305|      0|                    throw error
  306|      6|                case let (charact, _):
  307|      6|                    return charact
  308|      6|                }
  309|      6|            }
  310|      6|            .mapError {$0 as! LittleBluetoothError}
  311|      6|            .eraseToAnyPublisher()
  312|      6|        }
  313|      6|        .eraseToAnyPublisher()
  314|      6|        return notifyStop
  315|      6|    }
  316|       |    
  317|      2|    func writeAndListen(from charateristicUUID: CBUUID, of serviceUUID: CBUUID, data: Data) -> AnyPublisher<Data?, LittleBluetoothError> {
  318|      2|        
  319|      2|        let writeListen = startListen(from: charateristicUUID, of: serviceUUID)
  320|      2|            .flatMap { (_) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  321|      2|                self.write(to: charateristicUUID, of: serviceUUID, data: data)
  322|      2|            }
  323|      2|            .flatMap { (_) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  324|      2|                self.peripheralProxy.peripheralUpdatedValueForNotifyCharacteristicPublisher
  325|      2|                .tryMap { (value) -> CBCharacteristic in
  326|      2|                    switch value {
  327|      2|                    case let (_, error?):
  328|      0|                        throw error
  329|      2|                    case let (charact, _):
  330|      2|                        return charact
  331|      2|                    }
  332|      2|                }
  333|      2|                .mapError {$0 as! LittleBluetoothError}
  334|      2|                .eraseToAnyPublisher()
  335|      2|            }
  336|      2|            .prefix(1)
  337|      2|            .filter { (charachteristic) -> Bool in
  338|      2|                if charachteristic.uuid == charateristicUUID {
  339|      2|                    return true
  340|      2|                }
  341|      0|                return false
  342|      2|            }
  343|      2|            .flatMap{ (_) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  344|      2|                self.stopListen(from: charateristicUUID, of: serviceUUID)
  345|      2|            }
  346|      2|            .map { charact -> Data? in
  347|      2|                charact.value
  348|      2|            }
  349|      2|            .eraseToAnyPublisher()
  350|      2|        return writeListen
  351|      2|    }
  352|       |    
  353|       |}
  354|       |
  355|       |extension Peripheral: CustomDebugStringConvertible {
  356|     18|    public var debugDescription: String {
  357|     18|        return """
  358|     18|        Id: \(id)
  359|     18|        Name: \(name ?? "Not available")
  360|     18|        CBPeripheral: \(cbPeripheral)
  361|     18|        RSSI: \(rssi?.description ?? "Not available")
  362|     18|        """
  363|     18|    }
  364|       |}
  365|       |
  366|       |extension Peripheral: Loggable {}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Model/PeripheralDiscovery.swift:
    1|       |//
    2|       |//  PeripheralDiscovery.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |#if TEST
   11|       |import CoreBluetoothMock
   12|       |#else
   13|       |import CoreBluetooth
   14|       |#endif
   15|       |
   16|       |
   17|       |public protocol PeripheralIdentifiable: Identifiable {
   18|       |    var id: UUID {get set}
   19|       |    var name: String? {get set}
   20|       |}
   21|       |/// An object that contains the unique identifier of the `CBPeripheral` and the name of it (if present)
   22|       |public struct PeripheralIdentifier: PeripheralIdentifiable {
   23|       |    public var id: UUID
   24|       |    public var name: String?
   25|       |    public var cbPeripheral: CBPeripheral?
   26|       |    
   27|     75|    public init(peripheral: CBPeripheral) {
   28|     75|        self.id = peripheral.identifier
   29|     75|        self.name = peripheral.name
   30|     75|        self.cbPeripheral = peripheral
   31|     75|    }
   32|       |    
   33|      6|    public init(uuid: UUID, name: String? = nil) {
   34|      6|        self.id = uuid
   35|      6|        self.name = name
   36|      6|    }
   37|       |    
   38|      3|    public init(string: String, name: String? = nil) throws {
   39|      3|        if let id = UUID(uuidString: string) {
   40|      2|            self.init(uuid: id, name: name)
   41|      3|        } else {
   42|      1|            throw LittleBluetoothError.invalidUUID(string)
   43|      2|        }
   44|      2|    }
   45|       |}
   46|       |
   47|       |extension PeripheralIdentifier: CustomStringConvertible {
   48|     18|    public var description: String {
   49|     18|        return """
   50|     18|        UUID: \(id)
   51|     18|        Name: \(name ?? "not availbale")
   52|     18|        """
   53|     18|    }
   54|       |}
   55|       |
   56|       |/**
   57|       |An object that contains the unique identifier of the `CBPeripheral`, the name of it (if present) and the advertising info.
   58|       |*/
   59|       |public struct PeripheralDiscovery: PeripheralIdentifiable {
   60|       |        
   61|       |    public var id: UUID
   62|       |    public var name: String?
   63|       |    
   64|       |    public let cbPeripheral: CBPeripheral
   65|       |    public let advertisement: AdvertisingInfo
   66|       |    public let rssi: Int
   67|       |    
   68|     42|    init(_ peripheral: CBPeripheral, advertisement: [String : Any], rssi: NSNumber) {
   69|     42|        self.cbPeripheral = peripheral
   70|     42|        self.name = peripheral.name
   71|     42|        self.id = peripheral.identifier
   72|     42|        self.rssi = rssi.intValue
   73|     42|        self.advertisement = AdvertisingInfo(advertisementData: advertisement)
   74|     42|    }
   75|       |}
   76|       |
   77|       |extension PeripheralDiscovery: CustomDebugStringConvertible {
   78|     18|    public var debugDescription: String {
   79|     18|        return """
   80|     18|        Name: \(name ?? "not available")
   81|     18|        CB Peripheral: \(cbPeripheral)
   82|     18|        Adv: \(advertisement.debugDescription)
   83|     18|        RSSI: \(rssi)
   84|     18|        """
   85|     18|    }
   86|       |    
   87|       |    
   88|       |}
   89|       |
   90|       |extension PeripheralIdentifier: Equatable, Hashable {
   91|      2|    public static func == (lhs: Self, rhs: Self) -> Bool {
   92|      2|        if lhs.id == rhs.id  {
   93|      1|            return true
   94|      1|        }
   95|      1|        return false
   96|      2|    }
   97|       |    
   98|      0|    public func hash(into hasher: inout Hasher) {
   99|      0|        hasher.combine(id)
  100|      0|    }
  101|       |    
  102|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Proxies/CBCentralManagerDelegateProxy.swift:
    1|       |//
    2|       |//  CBManagerDelegateProxy.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Combine
   11|       |import os.log
   12|       |#if TEST
   13|       |import CoreBluetoothMock
   14|       |#else
   15|       |import CoreBluetooth
   16|       |#endif
   17|       |
   18|       |public enum ConnectionEvent {
   19|       |    case connected(CBPeripheral)
   20|       |    case autoConnected(CBPeripheral)
   21|       |    case ready(CBPeripheral)
   22|       |    case notReady(CBPeripheral, error: LittleBluetoothError?)
   23|       |    case connectionFailed(CBPeripheral, error: LittleBluetoothError?)
   24|       |    case disconnected(CBPeripheral, error: LittleBluetoothError?)
   25|       |}
   26|       |
   27|       |public enum BluetoothState {
   28|       |
   29|       |    case unknown
   30|       |    case resetting
   31|       |    case unsupported
   32|       |    case unauthorized
   33|       |    case poweredOff
   34|       |    case poweredOn
   35|       |    
   36|    878|    init(_ state: CBManagerState) {
   37|    878|        switch state {
   38|    878|        case .unknown:
   39|      0|            self = .unknown
   40|    878|        case .resetting:
   41|      0|            self = .resetting
   42|    878|        case .unsupported:
   43|      0|            self = .unsupported
   44|    878|        case .unauthorized:
   45|      0|            self = .unauthorized
   46|    878|        case .poweredOff:
   47|     90|            self = .poweredOff
   48|    878|        case .poweredOn:
   49|    788|            self = .poweredOn
   50|    878|        #if !TEST
   51|    878|        @unknown default:
   52|    878|            fatalError()
   53|    878|        #endif
   54|    878|        }
   55|    878|    }
   56|       |}
   57|       |
   58|       |class CBCentralManagerDelegateProxy: NSObject {
   59|       |    
   60|     45|    let centralDiscoveriesPublisher = PassthroughSubject<PeripheralDiscovery, Never>()
   61|     45|    let connectionEventPublisher = PassthroughSubject<ConnectionEvent, Never>()
   62|       |    lazy var centralStatePublisher: AnyPublisher<BluetoothState, Never>
   63|     40|        = {
   64|     40|            self._centralStatePublisher.eraseToAnyPublisher()
   65|     40|    }()
   66|       |
   67|     45|    lazy var willRestoreStatePublisher: AnyPublisher<CentralRestorer, Never> = {
   68|     45|        _willRestoreStatePublisher.shareReplay(1).eraseToAnyPublisher()
   69|     45|    }()
   70|       |    
   71|     45|    let _centralStatePublisher = CurrentValueSubject<BluetoothState, Never>(.unknown)
   72|     45|    let _willRestoreStatePublisher = PassthroughSubject<CentralRestorer, Never>()
   73|       |
   74|       |    var isLogEnabled: Bool = false
   75|       |    var isAutoconnectionActive = false
   76|       |    var stateRestorationCancellable: AnyCancellable!
   77|       |    
   78|     45|    override init() {
   79|     45|        super.init()
   80|     45|        self.stateRestorationCancellable = willRestoreStatePublisher.sink { _ in }
   81|     45|    }
   82|       |   
   83|       |}
   84|       |
   85|       |extension CBCentralManagerDelegateProxy: CBCentralManagerDelegate {
   86|    878|    func centralManagerDidUpdateState(_ central: CBCentralManager) {
   87|    878|        log("[LBT: CBCMD] DidUpdateState %{public}d",
   88|    878|            log: OSLog.LittleBT_Log_CentralManager,
   89|    878|            type: .debug,
   90|    878|            arg: central.state.rawValue)
   91|    878|       _centralStatePublisher.send(BluetoothState(central.state))
   92|    878|    }
   93|       |    
   94|       |    /// Scan
   95|     42|    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
   96|     42|        log("[LBT: CBCMD] DidDiscover %{public}@",
   97|     42|            log: OSLog.LittleBT_Log_CentralManager,
   98|     42|            type: .debug,
   99|     42|            arg: peripheral.description)
  100|     42|        let peripheraldiscovery = PeripheralDiscovery(peripheral, advertisement: advertisementData, rssi: RSSI)
  101|     42|        centralDiscoveriesPublisher.send(peripheraldiscovery)
  102|     42|    }
  103|       |    
  104|       |    /// Monitoring connection
  105|     34|    func centralManager(_ central: CBCentralManager, didConnect: CBPeripheral) {
  106|     34|        log("[LBT: CBCMD] DidConnect %{public}@",
  107|     34|            log: OSLog.LittleBT_Log_CentralManager,
  108|     34|            type: .debug,
  109|     34|            arg: didConnect.description)
  110|     34|        if isAutoconnectionActive {
  111|      1|            isAutoconnectionActive = false
  112|      1|            let event = ConnectionEvent.autoConnected(didConnect)
  113|      1|            connectionEventPublisher.send(event)
  114|     34|        } else {
  115|     33|            let event = ConnectionEvent.connected(didConnect)
  116|     33|            connectionEventPublisher.send(event)
  117|     34|        }
  118|     34|    }
  119|       |    
  120|     33|    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral: CBPeripheral, error: Error?) {
  121|     33|        log("[LBT: CBCMD] DidDisconnect %{public}@, Error %{public}@",
  122|     33|            log: OSLog.LittleBT_Log_CentralManager,
  123|     33|            type: .debug,
  124|     33|            arg: didDisconnectPeripheral.description,
  125|     33|            error?.localizedDescription ?? "")
  126|     33|        isAutoconnectionActive = false
  127|     33|        var lttlError: LittleBluetoothError?
  128|     33|        if let error = error {
  129|      3|            lttlError = .peripheralDisconnected(PeripheralIdentifier(peripheral: didDisconnectPeripheral), error)
  130|     33|        }
  131|     33|        let event = ConnectionEvent.disconnected(didDisconnectPeripheral, error: lttlError)
  132|     33|        connectionEventPublisher.send(event)
  133|     33|    }
  134|       |    
  135|      0|    func centralManager(_ central: CBCentralManager, didFailToConnect: CBPeripheral, error: Error?) {
  136|      0|        isAutoconnectionActive = false
  137|      0|        var lttlError: LittleBluetoothError?
  138|      0|        if let error = error {
  139|      0|            lttlError = .couldNotConnectToPeripheral(PeripheralIdentifier(peripheral: didFailToConnect), error)
  140|      0|        }
  141|      0|        let event = ConnectionEvent.connectionFailed(didFailToConnect, error: lttlError)
  142|      0|        connectionEventPublisher.send(event)
  143|      0|    }
  144|       |    
  145|      1|    func centralManager(_ central: CBCentralManager, willRestoreState dict: [String : Any]) {
  146|      1|        log("[LBT: CBCMD] WillRestoreState %{public}@",
  147|      1|            log: OSLog.LittleBT_Log_Restore,
  148|      1|            type: .debug,
  149|      1|            arg: dict.description)
  150|      1|        _willRestoreStatePublisher.send(CentralRestorer(centralManager: central, restoredInfo: dict))
  151|      1|    }
  152|       |    
  153|       |    #if !os(macOS)
  154|      0|    func centralManager(_ central: CBCentralManager, connectionEventDidOccur event: CBConnectionEvent, for peripheral: CBPeripheral) {}
  155|       |    #endif
  156|       |    
  157|       |}
  158|       |
  159|       |extension CBCentralManagerDelegateProxy: Loggable {}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Proxies/CBPeripheralProxy.swift:
    1|       |//
    2|       |//  CBPeripheralProxy.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Combine
   11|       |import os.log
   12|       |#if TEST
   13|       |import CoreBluetoothMock
   14|       |#else
   15|       |import CoreBluetooth
   16|       |#endif
   17|       |
   18|       |class CBPeripheralDelegateProxy: NSObject {
   19|       |    
   20|     36|    let peripheralChangesPublisher = PassthroughSubject<PeripheralChanges, Never>()
   21|     36|    let peripheralRSSIPublisher = PassthroughSubject<(Int, LittleBluetoothError?), Never>()
   22|     36|    let peripheralDiscoveredServicesPublisher = PassthroughSubject<([CBService]?, LittleBluetoothError?), Never>()
   23|     36|    let peripheralDiscoveredIncludedServicesPublisher = PassthroughSubject<(CBService, Error?), Never>()
   24|     36|    let peripheralDiscoveredCharacteristicsForServicePublisher = PassthroughSubject<(CBService, LittleBluetoothError?), Never>()
   25|     36|    let peripheralUpdatedValueForCharacteristicPublisher = PassthroughSubject<(CBCharacteristic, LittleBluetoothError?), Never>()
   26|     36|    let peripheralUpdatedValueForNotifyCharacteristicPublisher = PassthroughSubject<(CBCharacteristic, LittleBluetoothError?), Never>()
   27|     36|    let peripheralWrittenValueForCharacteristicPublisher = PassthroughSubject<(CBCharacteristic, LittleBluetoothError?), Never>()
   28|     36|    let peripheralIsReadyToSendWriteWithoutResponse = PassthroughSubject<Void, Never>()
   29|       |
   30|       |    let peripheralUpdatedNotificationStateForCharacteristicPublisher =
   31|     36|        PassthroughSubject<(CBCharacteristic, LittleBluetoothError?), Never>()
   32|       |    
   33|       |    let peripheralDiscoveredDescriptorsForCharacteristicPublisher =
   34|     36|        PassthroughSubject<(CBCharacteristic, LittleBluetoothError?), Never>()
   35|     36|    let peripheralUpdatedValueForDescriptor = PassthroughSubject<(CBDescriptor, LittleBluetoothError?), Never>()
   36|     36|    let peripheralWrittenValueForDescriptor = PassthroughSubject<(CBDescriptor, LittleBluetoothError?), Never>()
   37|       |    
   38|       |    var isLogEnabled: Bool = false
   39|       |
   40|       |}
   41|       |
   42|       |extension CBPeripheralDelegateProxy: CBPeripheralDelegate {
   43|       |    
   44|      0|    func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBPeripheral){
   45|      0|        log("[LBT: CBPD] ReadyToSendWRiteWOResp",
   46|      0|            log: OSLog.LittleBT_Log_Peripheral,
   47|      0|            type: .debug)
   48|      0|        peripheralIsReadyToSendWriteWithoutResponse.send()
   49|      0|    }
   50|       |
   51|      1|    func peripheralDidUpdateName(_ peripheral: CBPeripheral) {
   52|      1|        log("[LBT: CBPD] DidUpdateName %{public}@",
   53|      1|            log: OSLog.LittleBT_Log_Peripheral,
   54|      1|            type: .debug,
   55|      1|            arg: peripheral.name ?? "na")
   56|      1|        peripheralChangesPublisher.send(.name(peripheral.name))
   57|      1|    }
   58|       |
   59|      1|    func peripheral(_ peripheral: CBPeripheral, didModifyServices invalidatedServices: [CBService]){
   60|      1|        log("[LBT: CBPD] DidModifyServices %{public}@",
   61|      1|            log: OSLog.LittleBT_Log_Peripheral,
   62|      1|            type: .debug,
   63|      1|            arg: invalidatedServices.description)
   64|      1|        peripheralChangesPublisher.send(.invalidatedServices(invalidatedServices))
   65|      1|    }
   66|       |
   67|      2|    func peripheral(_ peripheral: CBPeripheral, didReadRSSI RSSI: NSNumber, error: Error?) {
   68|      2|        if let error = error {
   69|      0|            peripheralRSSIPublisher.send((RSSI.intValue,.couldNotReadRSSI(error)))
   70|      2|        } else {
   71|      2|            peripheralRSSIPublisher.send((RSSI.intValue, nil))
   72|      2|        }
   73|      2|    }
   74|       |
   75|     20|    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?){
   76|     20|        log("[LBT: CBPD] DidDiscoverServices, Error %{public}@",
   77|     20|            log: OSLog.LittleBT_Log_Peripheral,
   78|     20|            type: .debug,
   79|     20|            arg: error?.localizedDescription ?? "")
   80|     20|        if let error = error {
   81|      0|            peripheralDiscoveredServicesPublisher.send((nil,.serviceNotFound(error)))
   82|     20|        } else {
   83|     20|            peripheralDiscoveredServicesPublisher.send((peripheral.services, nil))
   84|     20|        }
   85|     20|    }
   86|       |
   87|      0|    func peripheral(_ peripheral: CBPeripheral, didDiscoverIncludedServicesFor service: CBService, error: Error?) {
   88|      0|        log("[LBT: CBPD] DidDiscoverIncludedServices %{public}@, Error %{public}@",
   89|      0|            log: OSLog.LittleBT_Log_Peripheral,
   90|      0|            type: .debug,
   91|      0|            arg: service.description,
   92|      0|            error?.localizedDescription ?? "")
   93|      0|        if let error = error {
   94|      0|            peripheralDiscoveredIncludedServicesPublisher.send((service, error))
   95|      0|        } else {
   96|      0|            peripheralDiscoveredIncludedServicesPublisher.send((service, nil))
   97|      0|        }
   98|      0|    }
   99|       |    
  100|     22|    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?){
  101|     22|        log("[LBT: CBPD] DidDiscoverCharacteristic %{public}@, Error %{public}@",
  102|     22|            log: OSLog.LittleBT_Log_Peripheral,
  103|     22|            type: .debug,
  104|     22|            arg: service.description,
  105|     22|            error?.localizedDescription ?? "")
  106|     22|        if let error = error {
  107|      0|            peripheralDiscoveredCharacteristicsForServicePublisher.send((service,  .characteristicNotFound(error)))
  108|     22|        } else {
  109|     22|            peripheralDiscoveredCharacteristicsForServicePublisher.send((service, nil))
  110|     22|        }
  111|     22|    }
  112|       |
  113|    132|    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?){
  114|    132|        log("[LBT: CBPD] DidUpdateValue %{public}@, Error %{public}@",
  115|    132|            log: OSLog.LittleBT_Log_Peripheral,
  116|    132|            type: .debug,
  117|    132|            arg: characteristic.description,
  118|    132|            error?.localizedDescription ?? "")
  119|    132|        if let error = error {
  120|      0|            peripheralUpdatedValueForCharacteristicPublisher.send((characteristic, .couldNotReadFromCharacteristic(characteristic: characteristic.uuid, error: error)))
  121|    132|        } else {
  122|    132|            if !characteristic.isNotifying {
  123|      8|                peripheralUpdatedValueForCharacteristicPublisher.send((characteristic, nil))
  124|    132|            } else {
  125|    124|                peripheralUpdatedValueForNotifyCharacteristicPublisher.send((characteristic, nil))
  126|    132|            }
  127|    132|        }
  128|    132|    }
  129|       |
  130|      4|    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
  131|      4|        log("[LBT: CBPD] DidWriteValue %{public}@, Error %{public}@",
  132|      4|            log: OSLog.LittleBT_Log_Peripheral,
  133|      4|            type: .debug,
  134|      4|            arg: characteristic.description,
  135|      4|            error?.localizedDescription ?? "")
  136|      4|        if let error = error {
  137|      0|            peripheralWrittenValueForCharacteristicPublisher.send((characteristic, .couldNotWriteFromCharacteristic(characteristic: characteristic.uuid, error: error)))
  138|      4|        } else {
  139|      4|            peripheralWrittenValueForCharacteristicPublisher.send((characteristic, nil))
  140|      4|        }
  141|      4|    }
  142|       |
  143|     16|    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?){
  144|     16|        log("[LBT: CBPD] DidUpdateNotifState %{public}@, Error %{public}@",
  145|     16|            log: OSLog.LittleBT_Log_Peripheral,
  146|     16|            type: .debug,
  147|     16|            arg: characteristic.description,
  148|     16|            error?.localizedDescription ?? "")
  149|     16|        if let error = error {
  150|      0|            peripheralUpdatedNotificationStateForCharacteristicPublisher.send((characteristic, .couldNotUpdateListenState(characteristic: characteristic.uuid, error: error)))
  151|     16|        } else {
  152|     16|            peripheralUpdatedNotificationStateForCharacteristicPublisher.send((characteristic, nil))
  153|     16|        }
  154|     16|    }
  155|       |
  156|       |    // MARK: - Descriptors
  157|       |//    func peripheral(_ peripheral: CBPeripheral, didDiscoverDescriptorsFor characteristic: CBCharacteristic, error: Error?){}
  158|       |//    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor descriptor: CBDescriptor, error: Error?){}
  159|       |//    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor descriptor: CBDescriptor, error: Error?){}
  160|       |}
  161|       |
  162|       |extension CBPeripheralDelegateProxy: Loggable {}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Utilities/ShareAndReplayOperator/ReplaySubject.swift:
    1|       |import Foundation
    2|       |import Combine
    3|       |
    4|       |public final class ReplaySubject<Output, Failure: Error>: Subject {
    5|     46|    private var buffer = [Output]()
    6|       |    private let bufferSize: Int
    7|     46|    private var subscriptions = [ReplaySubjectSubscription<Output, Failure>]()
    8|       |    private var completion: Subscribers.Completion<Failure>?
    9|     46|    private let lock = NSRecursiveLock()
   10|       |
   11|     46|    public init(_ bufferSize: Int = 0) {
   12|     46|        self.bufferSize = bufferSize
   13|     46|    }
   14|       |
   15|       |    /// Provides this Subject an opportunity to establish demand for any new upstream subscriptions
   16|     46|    public func send(subscription: Subscription) {
   17|     46|        lock.lock(); defer { lock.unlock() }
   18|     46|        subscription.request(.unlimited)
   19|     46|    }
   20|       |
   21|       |    /// Sends a value to the subscriber.
   22|      3|    public func send(_ value: Output) {
   23|      3|        lock.lock(); defer { lock.unlock() }
   24|      3|        buffer.append(value)
   25|      3|        buffer = buffer.suffix(bufferSize)
   26|      4|        subscriptions.forEach { $0.receive(value) }
   27|      3|    }
   28|       |
   29|       |    /// Sends a completion signal to the subscriber.
   30|      1|    public func send(completion: Subscribers.Completion<Failure>) {
   31|      1|        lock.lock(); defer { lock.unlock() }
   32|      1|        self.completion = completion
   33|      2|        subscriptions.forEach { subscription in subscription.receive(completion: completion) }
   34|      1|    }
   35|       |
   36|       |    /// This function is called to attach the specified `Subscriber` to the`Publisher
   37|     49|    public func receive<Downstream: Subscriber>(subscriber: Downstream) where Downstream.Failure == Failure, Downstream.Input == Output {
   38|     49|        lock.lock(); defer { lock.unlock() }
   39|     49|        let subscription = ReplaySubjectSubscription<Output, Failure>(downstream: AnySubscriber(subscriber))
   40|     49|        subscriber.receive(subscription: subscription)
   41|     49|        subscriptions.append(subscription)
   42|     49|        subscription.replay(buffer, completion: completion)
   43|     49|    }
   44|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Utilities/ShareAndReplayOperator/ReplaySubjectSubscription.swift:
    1|       |import Foundation
    2|       |import Combine
    3|       |
    4|       |/// A class representing the connection of a subscriber to a publisher.
    5|       |public final class ReplaySubjectSubscription<Output, Failure: Error>: Subscription {
    6|       |    private let downstream: AnySubscriber<Output, Failure>
    7|       |    private var isCompleted = false
    8|     49|    private var demand: Subscribers.Demand = .none
    9|       |
   10|     49|    public init(downstream: AnySubscriber<Output, Failure>) {
   11|     49|        self.downstream = downstream
   12|     49|    }
   13|       |
   14|       |    // Tells a publisher that it may send more values to the subscriber.
   15|     49|    public func request(_ newDemand: Subscribers.Demand) {
   16|     49|        demand += newDemand
   17|     49|    }
   18|       |
   19|      4|    public func cancel() {
   20|      4|        isCompleted = true
   21|      4|    }
   22|       |
   23|      7|    public func receive(_ value: Output) {
   24|      7|        guard !isCompleted, demand > 0 else { return }
   25|      7|
   26|      7|        demand += downstream.receive(value)
   27|      7|        demand -= 1
   28|      7|    }
   29|       |
   30|      2|    public func receive(completion: Subscribers.Completion<Failure>) {
   31|      2|        guard !isCompleted else { return }
   32|      2|        isCompleted = true
   33|      2|        downstream.receive(completion: completion)
   34|      2|    }
   35|       |
   36|     49|    public func replay(_ values: [Output], completion: Subscribers.Completion<Failure>?) {
   37|     49|        guard !isCompleted else { return }
   38|     49|        values.forEach { value in receive(value) }
   39|     49|        if let completion = completion { receive(completion: completion) }
   40|     49|    }
   41|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Utilities/ShareAndReplayOperator/ShareReplay.swift:
    1|       |import Foundation
    2|       |import Combine
    3|       |
    4|       |extension Publisher {
    5|       |    /// Provides a subject that shares a single subscription to the upstream publisher and replays at most `bufferSize` items emitted by that publisher
    6|       |    /// - Parameter bufferSize: limits the number of items that can be replayed
    7|     46|    public func shareReplay(_ bufferSize: Int) -> AnyPublisher<Output, Failure> {
    8|     46|        return multicast(subject: ReplaySubject(bufferSize)).autoconnect().eraseToAnyPublisher()
    9|     46|    }
   10|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/Classes/Utilities/Utilities.swift:
    1|       |//
    2|       |//  Utilities.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 12/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |public extension Data {
   11|       |    /// Deserialize a range of `Data` into a specific type
   12|       |    /// - parameter start: start position
   13|       |    /// - parameter lenght: number of bytes (8 bit) from start that you want to keep in range
   14|       |    /// - returns: Deserializaztion into a specific type.
   15|    134|    func extract<T>(start: Int, length: Int) throws -> T {
   16|    134|        if start + length > self.count {
   17|      1|            throw LittleBluetoothError.deserializationFailedDataOfBounds(start: start, length: length, count: self.count)
   18|    133|        }
   19|    133|        return self.subdata(in: start..<start + length).withUnsafeBytes { $0.load(as: T.self) }
   20|    134|    }
   21|       |}
   22|       |
   23|       |extension Data: Writable, Readable {
   24|      7|    public var data: Data {
   25|      7|        self
   26|      7|    }
   27|      1|    public init(from data: Data) {
   28|      1|        self = data
   29|      1|    }
   30|       |}
   31|       |
   32|       |extension UInt8: Writable, Readable {
   33|      3|   public var data: Data {
   34|      3|          Data([self])
   35|      3|    }
   36|      1|    public init(from data: Data) {
   37|      1|        self = data.map{$0}.first!
   38|      1|    }
   39|       |}
   40|       |
   41|       |public extension LittleBlueTooth {
   42|      1|    static func assemble(_ writables: [Writable]) -> Data {
   43|      1|        var data = Data()
   44|      1|        
   45|      2|        writables.forEach { (bite) in
   46|      2|            data.append(bite.data)
   47|      2|        }
   48|      1|        
   49|      1|        return data
   50|      1|    }
   51|       |}
   52|       |
   53|       |extension OptionSet where RawValue: FixedWidthInteger {
   54|       |
   55|    175|    func elements() -> AnySequence<Self> {
   56|    175|        var remainingBits = rawValue
   57|    175|        var bitMask: RawValue = 1
   58|    175|        return AnySequence {
   59|    649|            return AnyIterator {
   60|  1.05k|                while remainingBits != 0 {
   61|    875|                    defer { bitMask = bitMask &* 2 }
   62|    875|                    if remainingBits & bitMask != 0 {
   63|    474|                        remainingBits = remainingBits & ~bitMask
   64|    474|                        return Self(rawValue: bitMask)
   65|    474|                    }
   66|    401|                }
   67|    175|                return nil
   68|    649|            }
   69|    175|        }
   70|    175|    }
   71|       |}

/Users/Andrea/Documents/GitHub/LittleBlueTooth/Sources/LittleBlueTooth/LittleBlueTooth.swift:
    1|       |//
    2|       |//  LittleBlueTooth.swift
    3|       |//  LittleBlueTooth
    4|       |//
    5|       |//  Created by Andrea Finollo on 10/06/2020.
    6|       |//  Copyright © 2020 Andrea Finollo. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Combine
   11|       |import os.log
   12|       |#if TEST
   13|       |import CoreBluetoothMock
   14|       |#else
   15|       |import CoreBluetooth
   16|       |#endif
   17|       |
   18|       |public protocol Readable {
   19|       |    init(from data: Data) throws
   20|       |}
   21|       |
   22|       |public protocol Writable {
   23|       |    var data: Data {get}
   24|       |}
   25|       |
   26|       |/**
   27|       |`LittleBlueTooth` can control only one peripheral at time. It has an `id` properties to identifiy different instances.
   28|       |Please note that Apple do not enacourage the use of more `CBCentralManger` instances, due to resurce hits.
   29|       | [Link](https://developer.apple.com/forums/thread/20810)
   30|       | */
   31|       |public class LittleBlueTooth: Identifiable {
   32|       |    
   33|       |    // MARK: - Public variables
   34|       |    /// LittleBlueTooth instance identifier
   35|     45|    public let id = UUID()
   36|       |    
   37|       |    /// This is usefull when you have auto-reconnection and want to do some task right after a connection.
   38|       |    /// All other tasks will be delayed until this one ends.
   39|       |    public var connectionTasks: AnyPublisher<Void, LittleBluetoothError>?
   40|       |    
   41|       |    /// This handler must be used to handle connection process after a disconnession.
   42|       |    /// You can inspect the error and decide if an automatic connection is necessary.
   43|       |    /// If you return `true` the connection process will start, once the peripheral has been found a connection will be established.
   44|       |    /// If you return `false` iOS will not try to establish a connection
   45|       |    /// Connection process will remain active also in background if the app has the right
   46|       |    /// permission, to cancel just call `disconnect`.
   47|       |    /// When a connection will be established an `.autoConnected(PeripheralIdentifier)` event will be streamed to
   48|       |    /// the `connectionEventPublisher`
   49|       |    public var autoconnectionHandler: AutoconnectionHandler?
   50|       |    
   51|       |    /// Connected peripheral. `nil` if not connected or a connection is not requested
   52|       |    public var peripheral: Peripheral? {
   53|     79|        didSet {
   54|     79|            guard let per = peripheral else {
   55|     43|                return
   56|     43|            }
   57|     36|            per.isLogEnabled = isLogEnabled
   58|     36|        }
   59|       |    }
   60|       |    
   61|       |    /// Publisher that streams peripheral state  available only when a connection is requested for fine grained control
   62|      2|    public var peripheralStatePublisher: AnyPublisher<PeripheralState, Never> {
   63|      2|        _peripheralStatePublisher.eraseToAnyPublisher()
   64|      2|    }
   65|       |
   66|       |    /// Publisher that streams `ConnectionEvent`
   67|     45|    public lazy var connectionEventPublisher: AnyPublisher<ConnectionEvent, Never> = { [unowned self] in
   68|     45|        return self.centralProxy.connectionEventPublisher.share().eraseToAnyPublisher()
   69|     45|    }()
   70|       |    
   71|       |    /// Publish name and service changes
   72|      1|    public var changesStatePublisher: AnyPublisher<PeripheralChanges, Never> {
   73|      1|        _peripheralChangesPublisher.eraseToAnyPublisher()
   74|      1|    }
   75|       |    
   76|       |    /// Publish all values from `LittleBlueToothCharacteristic` that you are already listening to.
   77|       |    /// It's up to you to filter them and convert raw data to the `Readable` object.
   78|      4|    public var listenPublisher: AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> {
   79|      4|        return _listenPublisher
   80|    164|            .map { (characteristic) -> LittleBlueToothCharacteristic in
   81|    164|                LittleBlueToothCharacteristic(with: characteristic)
   82|    164|            }
   83|      4|            .eraseToAnyPublisher()
   84|      4|    }
   85|       |    
   86|      1|    public var restoreStatePublisher: AnyPublisher<CentralRestorer, Never> {
   87|      1|        return centralProxy.willRestoreStatePublisher
   88|      1|    }
   89|       |    
   90|       |    /// Enable logging disabled by default
   91|       |    /// Enable logging, log is made using os_log and it exposes some information even in release configuration
   92|       |    public var isLogEnabled: Bool {
   93|    413|        get {
   94|    413|            return _isLogEnabled
   95|    413|        }
   96|     45|        set {
   97|     45|            _isLogEnabled = newValue
   98|     45|            centralProxy.isLogEnabled = newValue
   99|     45|        }
  100|       |    }
  101|       |    
  102|       |    // MARK: - Private variables
  103|       |    /// Cancellable operation idendified by a `UUID` key
  104|     45|    private var disposeBag = [UUID : AnyCancellable]()
  105|       |    /// Scan cancellable operation
  106|       |    private var scanning: AnyCancellable?
  107|       |    /// Peripheral state  publisher. It will be created after `Peripheral` instance creation.
  108|       |    private var peripheralStatePublisherCancellable: Cancellable?
  109|       |    /// Peripheral changes  publisher. It will be created after `Peripheral` instance creation.
  110|       |    private var peripheralChangesPublisherCancellable: Cancellable?
  111|       |    /// Notification  publisher. It will be created after `Peripheral` instance creation.
  112|       |    private var listenPublisherCancellable: Cancellable?
  113|       |    /// Cancellable connection event subscriber.
  114|       |    private var connectionEventSubscriber: AnyCancellable?
  115|       |    private var connectionEventSubscriberPeri: AnyCancellable?
  116|       |
  117|     39|    private var _listenPublisher: Publishers.Multicast<AnyPublisher<CBCharacteristic, LittleBluetoothError>, PassthroughSubject<CBCharacteristic, LittleBluetoothError>> {
  118|     39|        if _listenPublisher_ == nil {
  119|     35|            let pub =
  120|     35|                ensureBluetoothState()
  121|     35|                .flatMapLatest { [unowned self] _ in
  122|     35|                    self.ensurePeripheralReady()
  123|     35|                }
  124|     67|                .flatMapLatest { [unowned self] _ in
  125|     67|                    self.peripheral!.listenPublisher
  126|     67|                }
  127|     35|                .share()
  128|     35|                .eraseToAnyPublisher()
  129|     35|            
  130|     35|            _listenPublisher_ = Publishers.Multicast(upstream: pub, createSubject:{ PassthroughSubject() })
  131|     35|            return _listenPublisher_!
  132|     35|        }
  133|      4|        return _listenPublisher_!
  134|     39|    }
  135|       |    
  136|       |    private var _listenPublisher_: Publishers.Multicast<AnyPublisher<CBCharacteristic, LittleBluetoothError>, PassthroughSubject<CBCharacteristic, LittleBluetoothError>>?
  137|       |    
  138|       |    /// Peripheral state connectable publisher. It will be connected after `Peripheral` instance creation.
  139|     38|    private var _peripheralStatePublisher: Publishers.MakeConnectable<AnyPublisher<PeripheralState, Never>> {
  140|     38|        if _peripheralStatePublisher_ == nil {
  141|     34|            _peripheralStatePublisher_ =  Just(())
  142|     36|            .flatMapLatest {
  143|     36|                self.peripheral!.peripheralStatePublisher
  144|     36|            }
  145|     34|            .eraseToAnyPublisher()
  146|     34|            .makeConnectable()
  147|     34|            return _peripheralStatePublisher_!
  148|     34|        }
  149|      4|        return _peripheralStatePublisher_!
  150|     38|    }
  151|       |    
  152|       |    private var _peripheralStatePublisher_: Publishers.MakeConnectable<AnyPublisher<PeripheralState, Never>>?
  153|       |
  154|       |
  155|       |    /// Peripheral changes connectable publisher. It will be connected after `Peripheral` instance creation.
  156|     37|    private var _peripheralChangesPublisher: Publishers.MakeConnectable<AnyPublisher<PeripheralChanges, Never>> {
  157|     37|        if _peripheralChangesPublisher_ == nil {
  158|     36|            _peripheralChangesPublisher_ =
  159|     36|                Just(())
  160|     36|                .flatMapLatest {
  161|     36|                    self.peripheral!.changesPublisher
  162|     36|                }
  163|     36|                .eraseToAnyPublisher()
  164|     36|                .makeConnectable()
  165|     36|            return _peripheralChangesPublisher_!
  166|     36|            
  167|     36|        }
  168|      1|        return _peripheralChangesPublisher_!
  169|     37|    }
  170|       |    
  171|       |    private var _peripheralChangesPublisher_: Publishers.MakeConnectable<AnyPublisher<PeripheralChanges, Never>>?
  172|       |    
  173|       |    private var restoreStateCancellable: AnyCancellable?
  174|       |    private var _isLogEnabled: Bool = false
  175|       |
  176|       |    var cbCentral: CBCentralManager
  177|     45|    var centralProxy = CBCentralManagerDelegateProxy()
  178|       |    
  179|       |    // MARK: - Init
  180|     45|    public init(with configuration: LittleBluetoothConfiguration) {
  181|     45|        #if TEST
  182|     45|        self.cbCentral = CBCentralManagerFactory.instance(delegate: self.centralProxy, queue: configuration.centralManagerQueue, options: configuration.centralManagerOptions, forceMock: true)
  183|     45|        #else
  184|     45|        self.cbCentral = CBCentralManager(delegate: self.centralProxy, queue: configuration.centralManagerQueue, options: configuration.centralManagerOptions)
  185|     45|        #endif
  186|     45|        self.autoconnectionHandler = configuration.autoconnectionHandler
  187|     45|        if (configuration.restoreHandler == nil &&
  188|     45|            configuration.centralManagerOptions?[CBCentralManagerOptionRestoreIdentifierKey] != nil) ||
  189|     45|            (configuration.restoreHandler != nil &&
  190|     44|                configuration.centralManagerOptions?[CBCentralManagerOptionRestoreIdentifierKey] == nil) {
  191|      1|            print("If you want to use state preservation/restoration you should probablu want to implement the `restoreHandler`")
  192|     45|        }
  193|     45|        attachSubscribers(with: configuration.restoreHandler)
  194|     45|        self.isLogEnabled = configuration.isLogEnabled
  195|     45|        log(
  196|     45|            "[LBT] init options %{public}@",
  197|     45|            log: OSLog.LittleBT_Log_General,
  198|     45|            type: .debug,
  199|     45|            arg: configuration.centralManagerOptions?.description ?? ""
  200|     45|        )
  201|     45|    }
  202|       |    
  203|     45|    func attachSubscribers(with restorehandler: ((Restored) -> Void)?) {
  204|     45|        self.connectionEventSubscriber =
  205|     45|            connectionEventPublisher
  206|    107|            .flatMap { [unowned self] (event) -> AnyPublisher<ConnectionEvent, Never> in
  207|    107|//                print("Received event \(event)")
  208|    107|                switch event {
  209|    107|                case .connected(let periph),
  210|     34|                     .autoConnected(let periph):
  211|     34|                    self.listenPublisherCancellable = self._listenPublisher.connect()
  212|     34|
  213|     34|                    if let connTask = self.connectionTasks {
  214|      1|                        // I'm doing a copy of the connectionTask so if something fails
  215|      1|                        // next time it will start over.
  216|      1|                        // TEMPORARY WORKAROUND: Those Dispatch async will make the states flow correctly in the process: first connect, then ready. Without it would be the contrary
  217|      1|                        return AnyPublisher(connTask)
  218|      1|                            .catch { [unowned self] (error) -> Just<Void> in
  219|      0|                                DispatchQueue.main.async {
  220|      0|                                    self.centralProxy.connectionEventPublisher.send(ConnectionEvent.notReady(periph, error: error))
  221|      0|                                }
  222|      0|                                return Just(())
  223|      0|                        }
  224|      1|                        .map { _ in
  225|      1|                            DispatchQueue.main.async {
  226|      1|                                self.centralProxy.connectionEventPublisher.send(ConnectionEvent.ready(periph))
  227|      1|                            }
  228|      1|                            return event
  229|      1|                        }
  230|      1|                        .eraseToAnyPublisher()
  231|     33|                    } else {
  232|     33|                        DispatchQueue.main.async {
  233|     33|                            self.centralProxy.connectionEventPublisher.send(ConnectionEvent.ready(periph))
  234|     33|                        }
  235|     33|                        return Just(event).eraseToAnyPublisher()
  236|    107|                    }
  237|    107|                default:
  238|     73|                    return Just(event).eraseToAnyPublisher()
  239|    107|                }
  240|    107|            }
  241|     45|                // This delay to make able other subscribers to receive notification
  242|     45|            .delay(for: .milliseconds(50), scheduler: DispatchQueue.main)
  243|    106|            .sink { [unowned self] (event) in
  244|    106|//                print("Sinking event \(event)")
  245|    106|                if case ConnectionEvent.disconnected( let peripheral, let error) = event {
  246|     38|                    self.cleanUpForDisconnection()
  247|     38|                    if let autoCon = self.autoconnectionHandler, let er = error {
  248|      1|                        let periph = PeripheralIdentifier(peripheral: peripheral)
  249|      1|                        if autoCon(periph, er) == true {
  250|      1|                            _ = self.connect(to: periph, autoreconnect: true)
  251|      1|                        }
  252|     38|                    }
  253|    106|            }
  254|    106|        }
  255|     45|        if let handler = restorehandler {
  256|      1|            self.restoreStateCancellable = centralProxy.willRestoreStatePublisher
  257|      1|            .map { [unowned self] (restorer) -> Restored in
  258|      1|                let restored = self.restore(restorer)
  259|      1|                return restored
  260|      1|            }
  261|      1|            .sink(receiveValue: { (restored) in
  262|      1|                handler(restored)
  263|      1|            })
  264|     45|        }
  265|     45|    }
  266|       |    
  267|      4|    deinit {
  268|      4|        print("Deinit: \(self)")
  269|      4|        disposeBag.forEach { (_, value) in
  270|      0|            value.cancel()
  271|      0|        }
  272|      4|        scanning?.cancel()
  273|      4|        connectionEventSubscriber?.cancel()
  274|      4|        disposeBag.removeAll()
  275|      4|        guard let peri = peripheral else {
  276|      0|            return
  277|      4|        }
  278|      4|        cbCentral.cancelPeripheralConnection(peri.cbPeripheral)
  279|      4|        
  280|      4|    }
  281|       |    // MARK: - RSSI
  282|      2|    public func readRSSI() -> AnyPublisher<Int, LittleBluetoothError> {
  283|      2|        let rssiSubject = PassthroughSubject<Int, LittleBluetoothError>()
  284|      2|        let key = UUID()
  285|      2|        
  286|      2|        self.ensureBluetoothState()
  287|      2|        .customPrint("[LBT] Read RSSI", isEnabled: isLogEnabled)
  288|      2|        .flatMap { [unowned self] _ in
  289|      2|            self.ensurePeripheralReady()
  290|      2|        }
  291|      2|        .flatMap { [unowned self] _ in
  292|      2|            self.peripheral!.readRSSI()
  293|      2|        }
  294|      2|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  295|      0|            switch completion {
  296|      0|            case .finished:
  297|      0|                break
  298|      0|            case .failure(let error):
  299|      0|                rssiSubject.send(completion: .failure(error))
  300|      0|                self.removeAndCancelSubscriber(for: key)
  301|      0|            }
  302|      2|        }) { [unowned self, key] (rssi) in
  303|      2|            rssiSubject.send(rssi)
  304|      2|            rssiSubject.send(completion: .finished)
  305|      2|            self.removeAndCancelSubscriber(for: key)
  306|      2|        }
  307|      2|        .store(in: &disposeBag, for: key)
  308|      2|        
  309|      2|        return rssiSubject.eraseToAnyPublisher()
  310|      2|    }
  311|       |
  312|       |    // MARK: - Listen
  313|       |    
  314|       |    /// Returns a multicast publisher once you attached all the subscriber you must call `connect()`
  315|       |    /// - parameter characteristic: Characteristc you want to be notified.
  316|       |    /// - parameter valueType: The type of the value you want the raw `Data` be converted
  317|       |    /// - returns: A multicast publisher that will send out values of the type you choose.
  318|       |    /// - important: The type of the value must be conform to `Readable`
  319|      1|    public func connectableListenPublisher<T: Readable>(for characteristic: LittleBlueToothCharacteristic, valueType: T.Type) -> Publishers.MakeConnectable<AnyPublisher<T, LittleBluetoothError>> {
  320|      1|        
  321|      1|           let listen = ensureBluetoothState()
  322|      1|           .customPrint("[LBT] ConnectableListenPublisher", isEnabled: isLogEnabled)
  323|      1|           .flatMap { [unowned self] _ in
  324|      1|               self.ensurePeripheralReady()
  325|      1|           }
  326|      1|           .flatMap { (periph) -> AnyPublisher<(CBCharacteristic, Peripheral), LittleBluetoothError> in
  327|      1|               return periph.startListen(from: characteristic.id, of: characteristic.service)
  328|      1|                   .map { (characteristic) -> (CBCharacteristic, Peripheral) in
  329|      1|                       (characteristic, periph)
  330|      1|               }
  331|      1|               .eraseToAnyPublisher()
  332|      1|           }
  333|      1|           .flatMap { (_ ,periph) in
  334|      1|               periph.listenPublisher
  335|      1|           }
  336|     10|           .filter { charact -> Bool in
  337|     10|             charact.uuid == characteristic.id
  338|     10|           }
  339|     10|           .tryMap { (characteristic) -> T in
  340|     10|               guard let data = characteristic.value else {
  341|      0|                   throw LittleBluetoothError.emptyData
  342|     10|               }
  343|     10|               return try T.init(from: data)
  344|     10|           }.mapError { (error) -> LittleBluetoothError in
  345|      1|               if let er = error as? LittleBluetoothError {
  346|      1|                   return er
  347|      1|               }
  348|      0|               return .emptyData
  349|      1|           }
  350|      1|           .share()
  351|      1|           .eraseToAnyPublisher()
  352|      1|           
  353|      1|        return  Publishers.MakeConnectable(upstream: listen)
  354|      1|       }
  355|       |    
  356|       |       
  357|       |    /// Returns a shared publisher for listening to a specific characteristic.
  358|       |    /// - parameter characteristic: Characteristc you want to be notified.
  359|       |    /// - returns: A shared publisher that will send out values of the type defined by the generic type.
  360|       |    /// - important: The type of the value must be conform to `Readable`
  361|      3|    public func startListen<T: Readable>(from charact: LittleBlueToothCharacteristic) -> AnyPublisher<T, LittleBluetoothError> {
  362|      3|        let lis = ensureBluetoothState()
  363|      3|        .customPrint("[LBT] StartListenPublisher", isEnabled: isLogEnabled)
  364|      3|        .flatMap { [unowned self] _ in
  365|      3|            self.ensurePeripheralReady()
  366|      3|        }
  367|      3|        .flatMap { (periph) -> AnyPublisher<(LittleBlueToothCharacteristic, Peripheral), LittleBluetoothError> in
  368|      3|            return periph.startListen(from: charact.id, of: charact.service)
  369|      3|                .map { (characteristic) -> (LittleBlueToothCharacteristic, Peripheral) in
  370|      3|                    (LittleBlueToothCharacteristic(with: characteristic), periph)
  371|      3|            }
  372|      3|            .eraseToAnyPublisher()
  373|      3|        }
  374|      3|        .flatMap { (_ ,periph) in
  375|      3|            periph.listenPublisher
  376|      3|        }
  377|     30|        .filter { characteristic -> Bool in
  378|     30|            charact.id == characteristic.uuid
  379|     30|        }
  380|     30|        .tryMap { (characteristic) -> T in
  381|     30|            guard let data = characteristic.value else {
  382|      0|                throw LittleBluetoothError.emptyData
  383|     30|            }
  384|     30|            return try T.init(from: data)
  385|     30|        }.mapError { (error) -> LittleBluetoothError in
  386|      3|            if let er = error as? LittleBluetoothError {
  387|      3|                return er
  388|      3|            }
  389|      0|            return .emptyData
  390|      3|        }
  391|      3|        .eraseToAnyPublisher()
  392|      3|        return lis
  393|      3|        
  394|      3|    }
  395|       |    
  396|       |    /// Returns a  publisher with the `LittleBlueToothCharacteristic` where the notify command has been activated.
  397|       |    /// After starting the listen command you should subscribe to the `listenPublisher` to be notified.
  398|       |    /// - parameter characteristic: Characteristc you want to be notified.
  399|       |    /// - returns: A  publisher with the `LittleBlueToothCharacteristic` where the notify command has been activated.
  400|       |    /// - important: This publisher only activate the notification on a specific characteristic, it will not send notified values.
  401|       |    /// After starting the listen command you should subscribe to the `listenPublisher` to be notified.
  402|      4|    public func enableListen(from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> {
  403|      4|        
  404|      4|        let startListenSubject = PassthroughSubject<LittleBlueToothCharacteristic, LittleBluetoothError>()
  405|      4|        let key = UUID()
  406|      4|        
  407|      4|        self.ensureBluetoothState()
  408|      4|        .customPrint("[LBT] StartListenPublisher no Value", isEnabled: isLogEnabled)
  409|      4|        .flatMap { [unowned self] _ in
  410|      4|            self.ensurePeripheralReady()
  411|      4|        }
  412|      4|        .flatMap { (periph) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  413|      4|            periph.startListen(from: characteristic.id, of: characteristic.service)
  414|      4|        }
  415|      4|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  416|      0|            switch completion {
  417|      0|            case .finished:
  418|      0|                break
  419|      0|            case .failure(let error):
  420|      0|                startListenSubject.send(completion: .failure(error))
  421|      0|                self.removeAndCancelSubscriber(for: key)
  422|      0|            }
  423|      4|        }) { [unowned self, key] (characteristic) in
  424|      4|            startListenSubject.send(LittleBlueToothCharacteristic(with: characteristic))
  425|      4|            startListenSubject.send(completion: .finished)
  426|      4|            self.removeAndCancelSubscriber(for: key)
  427|      4|        }
  428|      4|        .store(in: &disposeBag, for: key)
  429|      4|        
  430|      4|        return startListenSubject.eraseToAnyPublisher()
  431|      4|    }
  432|       |    
  433|       |    
  434|       |    /// Disable listen from a specific characteristic
  435|       |    /// - parameter characteristic: characteristic you want to stop listen
  436|       |    /// - returns: A publisher with that informs you about the successful or failed task
  437|      4|    public func disableListen(from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<LittleBlueToothCharacteristic, LittleBluetoothError> {
  438|      4|        
  439|      4|        let stopSubject = PassthroughSubject<LittleBlueToothCharacteristic, LittleBluetoothError>()
  440|      4|        
  441|      4|        let key = UUID()
  442|      4|        ensureBluetoothState()
  443|      4|        .flatMap { [unowned self] _ in
  444|      4|            self.ensurePeripheralReady()
  445|      4|        }
  446|      4|        .flatMap { (periph) -> AnyPublisher<CBCharacteristic, LittleBluetoothError> in
  447|      4|            periph.stopListen(from: characteristic.id, of: characteristic.service)
  448|      4|        }
  449|      4|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  450|      0|            switch completion {
  451|      0|            case .finished:
  452|      0|                break
  453|      0|            case .failure(let error):
  454|      0|                stopSubject.send(completion: .failure(error))
  455|      0|                self.removeAndCancelSubscriber(for: key)
  456|      0|            }
  457|      4|        }) { [unowned self, key] (readvalue) in
  458|      4|            stopSubject.send(LittleBlueToothCharacteristic(with:readvalue))
  459|      4|            stopSubject.send(completion: .finished)
  460|      4|            self.removeAndCancelSubscriber(for: key)
  461|      4|        }
  462|      4|        .store(in: &disposeBag, for: key)
  463|      4|        
  464|      4|        return stopSubject.eraseToAnyPublisher()
  465|      4|    }
  466|       |
  467|       |    // MARK: - Read
  468|       |    
  469|       |    /// Read a value from a specific charteristic
  470|       |    /// - parameter characteristic: characteristic where you want to read
  471|       |    /// - returns: A publisher with the value you want to read.
  472|       |    /// - important: The type of the value must be conform to `Readable`
  473|     12|    public func read<T: Readable>(from characteristic: LittleBlueToothCharacteristic) -> AnyPublisher<T, LittleBluetoothError> {
  474|     12|        
  475|     12|        let readSubject = PassthroughSubject<T, LittleBluetoothError>()
  476|     12|        let key = UUID()
  477|     12|        
  478|     12|        ensureBluetoothState()
  479|     12|        .customPrint("[LBT] ReadPublisher", isEnabled: isLogEnabled)
  480|     12|        .flatMap { [unowned self] _ in
  481|     12|            self.ensurePeripheralReady()
  482|     12|        }
  483|     12|        .flatMap { periph in
  484|     12|            periph.read(from: characteristic.id, of: characteristic.service)
  485|     12|        }
  486|     12|        .tryMap { (data) -> T in
  487|      8|            guard let data = data else {
  488|      0|                throw LittleBluetoothError.emptyData
  489|      8|            }
  490|      8|            return try T.init(from: data)
  491|      8|        }
  492|     12|        .mapError { (error) -> LittleBluetoothError in
  493|      4|            if let er = error as? LittleBluetoothError {
  494|      4|                return er
  495|      4|            }
  496|      0|            return .couldNotReadFromCharacteristic(characteristic: characteristic.id, error: error)
  497|      4|        }
  498|     12|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  499|      4|            switch completion {
  500|      4|            case .finished:
  501|      0|                break
  502|      4|            case .failure(let error):
  503|      4|                readSubject.send(completion: .failure(error))
  504|      4|                self.removeAndCancelSubscriber(for: key)
  505|      4|            }
  506|      8|        }) { [unowned self, key] (readvalue) in
  507|      8|            readSubject.send(readvalue)
  508|      8|            readSubject.send(completion: .finished)
  509|      8|            self.removeAndCancelSubscriber(for: key)
  510|      8|        }
  511|     12|        .store(in: &disposeBag, for: key)
  512|     12|        
  513|     12|        return readSubject.eraseToAnyPublisher()
  514|     12|    }
  515|       |    
  516|       |    
  517|       |   // MARK: - Write
  518|       |
  519|       |    /// Write a value to a specific charteristic
  520|       |    /// - parameter characteristic: characteristic where you want to write
  521|       |    /// - parameter value: The value you want to write
  522|       |    /// - parameter response: An optional `Bool` value that will look for error after write operation
  523|       |    /// - returns: A publisher with that informs you about eventual error
  524|       |    /// - important: The type of the value must be conform to `Writable`
  525|      4|    public func write<T: Writable>(to characteristic: LittleBlueToothCharacteristic, value: T, response: Bool = true) -> AnyPublisher<Void, LittleBluetoothError> {
  526|      4|        
  527|      4|        let writeSubject = PassthroughSubject<Void, LittleBluetoothError>()
  528|      4|        let key = UUID()
  529|      4|
  530|      4|        ensureBluetoothState()
  531|      4|        .customPrint("[LBT] WritePublisher", isEnabled: isLogEnabled)
  532|      4|        .flatMap { [unowned self] _ in
  533|      4|            self.ensurePeripheralReady()
  534|      4|        }
  535|      4|        .flatMap { periph in
  536|      4|            periph.write(to: characteristic.id, of: characteristic.service, data: value.data, response: response)
  537|      4|        }
  538|      4|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  539|      0|            switch completion {
  540|      0|            case .finished:
  541|      0|                break
  542|      0|            case .failure(let error):
  543|      0|                writeSubject.send(completion: .failure(error))
  544|      0|                self.removeAndCancelSubscriber(for: key)
  545|      0|            }
  546|      4|        }, receiveValue: { [unowned self, key] (_) in
  547|      4|            writeSubject.send(())
  548|      4|            writeSubject.send(completion: .finished)
  549|      4|            self.removeAndCancelSubscriber(for: key)
  550|      4|        })
  551|      4|        .store(in: &disposeBag, for: key)
  552|      4|        
  553|      4|        return writeSubject.eraseToAnyPublisher()
  554|      4|    }
  555|       |    
  556|       |    
  557|       |    /// Write a value to a specific charteristic and wait for a response
  558|       |    /// - parameter characteristic: characteristic where you want to write and listen
  559|       |    /// - parameter value: The value you want to write must conform to `Writable`
  560|       |    /// - returns: A publisher with that post and error or the response of the write requests.
  561|       |    /// - important: Written value must conform to `Writable`, response must conform to `Readable`
  562|      2|    public func writeAndListen<W: Writable, R: Readable>(from characteristic: LittleBlueToothCharacteristic, value: W) -> AnyPublisher<R, LittleBluetoothError> {
  563|      2|
  564|      2|        let writeListenSubject = PassthroughSubject<R, LittleBluetoothError>()
  565|      2|        let key = UUID()
  566|      2|
  567|      2|        ensureBluetoothState()
  568|      2|        .customPrint("[LBT] WriteAndListePublisher", isEnabled: isLogEnabled)
  569|      2|        .flatMap { [unowned self] _ in
  570|      2|            self.ensurePeripheralReady()
  571|      2|        }
  572|      2|        .flatMap { (periph) in
  573|      2|            periph.writeAndListen(from: characteristic.id, of: characteristic.service, data: value.data)
  574|      2|        }
  575|      2|        .tryMap { (data) -> R in
  576|      2|            guard let data = data else {
  577|      0|                throw LittleBluetoothError.emptyData
  578|      2|            }
  579|      2|            return try R(from: data)
  580|      2|        }.mapError { (error) -> LittleBluetoothError in
  581|      0|            if let er = error as? LittleBluetoothError {
  582|      0|                return er
  583|      0|            }
  584|      0|            return .couldNotReadFromCharacteristic(characteristic: characteristic.id, error: error)
  585|      0|        }
  586|      2|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  587|      0|            switch completion {
  588|      0|            case .finished:
  589|      0|                break
  590|      0|            case .failure(let error):
  591|      0|                writeListenSubject.send(completion: .failure(error))
  592|      0|                self.removeAndCancelSubscriber(for: key)
  593|      0|            }
  594|      2|        }) { [unowned self, key] (readvalue) in
  595|      2|            writeListenSubject.send(readvalue)
  596|      2|            writeListenSubject.send(completion: .finished)
  597|      2|            self.removeAndCancelSubscriber(for: key)
  598|      2|        }
  599|      2|        .store(in: &disposeBag, for: key)
  600|      2|        
  601|      2|        return writeListenSubject.eraseToAnyPublisher()
  602|      2|    }
  603|       |    
  604|       |    // MARK: - Discover
  605|       |
  606|       |    /// Starts scanning for `PeripheralDiscovery`
  607|       |    /// - parameter services: Services for peripheral you are looking for
  608|       |    /// - parameter options: Scanning options same as  CoreBluetooth  central manager option.
  609|       |    /// - returns: A publisher with stream of disovered peripherals.
  610|     40|    public func startDiscovery(withServices services: [CBUUID]?, options: [String : Any]? = nil) -> AnyPublisher<PeripheralDiscovery, LittleBluetoothError> {
  611|     40|        if self.cbCentral.isScanning {
  612|      0|            self.cbCentral.stopScan()
  613|      0|//            return Result<PeripheralDiscovery, LittleBluetoothError>.Publisher(.failure(.alreadyScanning)).eraseToAnyPublisher()
  614|     40|        }
  615|     40|        
  616|     40|        let scanSubject = PassthroughSubject<PeripheralDiscovery, LittleBluetoothError>()
  617|     40|
  618|     40|        scanning =
  619|     40|        ensureBluetoothState()
  620|     40|        .customPrint("[LBT] DiscoverPublisher", isEnabled: isLogEnabled)
  621|     40|        .map { [unowned self] _  -> Void in
  622|     39|            if self.cbCentral.isScanning {
  623|      0|                self.cbCentral.stopScan()
  624|     39|            }
  625|     39|            return ()
  626|     39|        }
  627|     40|        .flatMap { [unowned self] _  -> Publishers.SetFailureType<PassthroughSubject<PeripheralDiscovery, Never>, LittleBluetoothError> in
  628|     39|            self.cbCentral.scanForPeripherals(withServices: services, options: options)
  629|     39|            return self.centralProxy.centralDiscoveriesPublisher.setFailureType(to: LittleBluetoothError.self)
  630|     39|        }
  631|     40|        .sink(receiveCompletion: { [unowned self] (completion) in
  632|      1|            switch completion {
  633|      1|            case .finished:
  634|      0|                break
  635|      1|            case .failure(let error):
  636|      1|                scanSubject.send(completion: .failure(error))
  637|      1|                self.cbCentral.stopScan()
  638|      1|                self.scanning?.cancel()
  639|      1|                self.scanning = nil
  640|      1|            }
  641|     42|        }) { (discovery) in
  642|     42|            scanSubject.send(discovery)
  643|     42|        }
  644|     40|        
  645|     40|        return scanSubject.eraseToAnyPublisher()
  646|     40|    }
  647|       |    
  648|       |    /// Stops peripheral discovery
  649|       |    /// - returns: A publisher when discovery has been stopped
  650|      6|    public func stopDiscovery() -> AnyPublisher<Void, LittleBluetoothError> {
  651|      6|        return Deferred {
  652|      6|            Future<Void, LittleBluetoothError> { [unowned self] promise in
  653|      6|                self.cbCentral.stopScan()
  654|      6|                self.scanning?.cancel()
  655|      6|                self.scanning = nil
  656|      6|                promise(.success(()))
  657|      6|            }
  658|      6|        }.eraseToAnyPublisher()
  659|      6|    }
  660|       |    
  661|       |    // MARK: - Connect
  662|       |    
  663|       |    /// Starts connection for `PeripheralIdentifier`
  664|       |    /// - parameter options: Connecting options same as  CoreBluetooth  central manager option.
  665|       |    /// - returns: A publisher with the just connected `Peripheral`.
  666|     35|    public func connect(to peripheralIdentifier: PeripheralIdentifier, options: [String : Any]? = nil) -> AnyPublisher<Peripheral, LittleBluetoothError> {
  667|     35|        return connect(to: peripheralIdentifier, options: options, autoreconnect: false)
  668|     35|    }
  669|       |    
  670|       |    /// Starts connection for `PeripheralDiscovery`
  671|       |    /// - parameter options: Connecting options same as  CoreBluetooth  central manager option.
  672|       |    /// - returns: A publisher with the just connected `Peripheral`.
  673|     34|    public func connect(to discovery: PeripheralDiscovery, options: [String : Any]? = nil) -> AnyPublisher<Peripheral, LittleBluetoothError> {
  674|     34|        if cbCentral.isScanning {
  675|     33|            scanning?.cancel()
  676|     33|            scanning = nil
  677|     33|            cbCentral.stopScan()
  678|     34|        }
  679|     34|        let peripheralIdentifier = PeripheralIdentifier(peripheral: discovery.cbPeripheral)
  680|     34|        
  681|     34|        return connect(to: peripheralIdentifier, options: options)
  682|     34|    }
  683|       |    
  684|     36|    private func connect(to peripheralIdentifier: PeripheralIdentifier, options: [String : Any]? = nil, autoreconnect: Bool) -> AnyPublisher<Peripheral, LittleBluetoothError> {
  685|     36|        if let periph = peripheral, periph.state == .connecting || periph.state == .connected {
  686|      1|            return Result<Peripheral, LittleBluetoothError>.Publisher(.failure(.peripheralAlreadyConnectedOrConnecting(periph))).eraseToAnyPublisher()
  687|     35|        }
  688|     35|        
  689|     35|        let connectSubject = PassthroughSubject<Peripheral, LittleBluetoothError>()
  690|     35|        let key = UUID()
  691|     35|        
  692|     35|        ensureBluetoothState()
  693|     35|        .customPrint("[LBT] ConnectPublisher", isEnabled: isLogEnabled)
  694|     35|        .tryMap { [unowned self] _ -> Void in
  695|     35|            let filtered = self.cbCentral.retrievePeripherals(withIdentifiers: [peripheralIdentifier.id]).filter { (periph) -> Bool in
  696|     35|                periph.identifier == peripheralIdentifier.id
  697|     35|            }
  698|     35|            if filtered.isEmpty {
  699|      0|                throw LittleBluetoothError.peripheralNotFound
  700|     35|            }
  701|     35|            self.peripheral = Peripheral(filtered.first!)
  702|     35|            self.peripheral!.isLogEnabled = self.isLogEnabled
  703|     35|            self.peripheralStatePublisherCancellable = self._peripheralStatePublisher.connect()
  704|     35|            self.peripheralChangesPublisherCancellable = self._peripheralChangesPublisher.connect()
  705|     35|            self.centralProxy.isAutoconnectionActive = autoreconnect
  706|     35|            self.cbCentral.connect(filtered.first!, options: options)
  707|     35|        }.mapError { error in
  708|      0|            error as! LittleBluetoothError
  709|      0|        }
  710|     35|        .flatMap { [unowned self] _ in
  711|     35|            self.centralProxy.connectionEventPublisher.setFailureType(to: LittleBluetoothError.self)
  712|     35|        }
  713|     69|        .filter{ (event) -> Bool in
  714|     69|//            print("Connct to event: \(event)")
  715|     69|            switch event {
  716|     69|                case .connected( _),
  717|     34|                     .autoConnected( _):
  718|     34|               return false
  719|     69|            default:
  720|     35|                return true
  721|     69|            }
  722|     69|        }
  723|     35|        .prefix(1)
  724|     35|        .tryMap { [unowned self] (event) -> CBPeripheral in
  725|     35|            switch event {
  726|     35|            case .ready(let periph):
  727|     34|                return periph
  728|     35|            case .notReady(_, let error?):
  729|      0|                self.cbCentral.cancelPeripheralConnection(self.peripheral!.cbPeripheral)
  730|      0|                self.peripheral = nil
  731|      0|                throw error
  732|     35|            case .connectionFailed(_, let error?):
  733|      0|                self.cbCentral.cancelPeripheralConnection(self.peripheral!.cbPeripheral)
  734|      0|                self.peripheral = nil
  735|      0|                throw error
  736|     35|            case .connectionFailed(let periph, _):
  737|      0|                self.cbCentral.cancelPeripheralConnection(self.peripheral!.cbPeripheral)
  738|      0|                self.peripheral = nil
  739|      0|                throw LittleBluetoothError.couldNotConnectToPeripheral(PeripheralIdentifier(peripheral: periph), nil)
  740|     35|            case .disconnected(_, let error?):
  741|      0|                self.cbCentral.cancelPeripheralConnection(self.peripheral!.cbPeripheral)
  742|      0|                self.peripheral = nil
  743|      0|                throw error
  744|     35|            case .disconnected(let periph, _):
  745|      1|                self.cbCentral.cancelPeripheralConnection(self.peripheral!.cbPeripheral)
  746|      1|                self.peripheral = nil
  747|      1|                throw LittleBluetoothError.peripheralDisconnected(PeripheralIdentifier(peripheral: periph), nil)
  748|     35|            default:
  749|      0|                fatalError("Connection event not handled")
  750|     35|            }
  751|     35|        }
  752|     35|        .mapError { (error) -> LittleBluetoothError in
  753|      1|                error as! LittleBluetoothError
  754|      1|        }
  755|     35|        .map { [unowned self] peripheral -> Peripheral in
  756|     34|            return self.peripheral!
  757|     34|        }
  758|     35|        .sink(receiveCompletion: { [unowned self, key] (completion) in
  759|      1|            switch completion {
  760|      1|            case .finished:
  761|      0|                break
  762|      1|            case .failure(let error):
  763|      1|                connectSubject.send(completion: .failure(error))
  764|      1|                self.peripheral = nil
  765|      1|                self.removeAndCancelSubscriber(for: key)
  766|      1|            }
  767|     34|        }, receiveValue: { [unowned self, key] (peripheral) in
  768|     34|            connectSubject.send(peripheral)
  769|     34|            connectSubject.send(completion: .finished)
  770|     34|            self.removeAndCancelSubscriber(for: key)
  771|     34|        })
  772|     35|        .store(in: &disposeBag, for: key)
  773|     35|        
  774|     35|        return connectSubject.eraseToAnyPublisher()
  775|     36|    }
  776|       |    
  777|       |    // MARK: - Disconnect
  778|       |
  779|       |    /// Disconnect the connected `Peripheral`
  780|       |    /// - returns: A publisher with the just disconnected `Peripheral` or a `LittleBluetoothError`
  781|       |    @discardableResult
  782|     31|    public func disconnect() -> AnyPublisher<Peripheral, LittleBluetoothError> {
  783|     31|        
  784|     31|        guard let periph = self.peripheral else {
  785|      1|            return Result<Peripheral, LittleBluetoothError>.Publisher(.failure(.peripheralNotConnectedOrAlreadyDisconnected)).eraseToAnyPublisher()
  786|     30|        }
  787|     30|        
  788|     30|        let disconnectionSubject = PassthroughSubject<Peripheral, LittleBluetoothError>()
  789|     30|        let key = UUID()
  790|     30|        
  791|     30|        self.centralProxy.connectionEventPublisher
  792|     30|        .customPrint("[LBT] DisconnectPublisher", isEnabled: isLogEnabled)
  793|     30|        .filter{ (event) -> Bool in
  794|     30|            if case ConnectionEvent.disconnected(_, error: _) = event {
  795|     30|                return true
  796|     30|            }
  797|      0|            return false
  798|     30|        }
  799|     30|        .sink { [unowned self, key, periph] (event) in
  800|     30|            if case ConnectionEvent.disconnected( _, let error) = event {
  801|     30|                if error != nil {
  802|      0|                    disconnectionSubject.send(completion: .failure(error!))
  803|     30|                } else {
  804|     30|                    disconnectionSubject.send(periph)
  805|     30|                    disconnectionSubject.send(completion: .finished)
  806|     30|                }
  807|     30|                self.removeAndCancelSubscriber(for: key)
  808|     30|                // Everything is cleaned in the connection event observer
  809|     30|            }
  810|     30|        }
  811|     30|        .store(in: &disposeBag, for: key)
  812|     30|        
  813|     30|        self.cbCentral.cancelPeripheralConnection(peripheral!.cbPeripheral)
  814|     30|        return disconnectionSubject.eraseToAnyPublisher()
  815|     31|    }
  816|       |    
  817|       |    // MARK: - Extraction and restart
  818|       |    /// Sometimes you may need to extract `CBCentralManager` and `CBPeripheral`
  819|       |    /// During this operation everything is stopped, delegates are set to nil current operation cancelled
  820|       |    /// - returns: A tuple with the central and the peripheral if connected
  821|      3|    public func extract() -> (central: CBCentralManager, peripheral: CBPeripheral?) {
  822|      3|        let cbCentral = self.cbCentral
  823|      3|        let cbPeripheral = self.peripheral?.cbPeripheral
  824|      3|        cbCentral.delegate = nil
  825|      3|        cbPeripheral?.delegate = nil
  826|      3|        // Clean operation
  827|      3|        cleanUpForExtraction()
  828|      3|        return (central: cbCentral, peripheral: cbPeripheral)
  829|      3|    }
  830|       |    
  831|      1|    public func restart(with central: CBCentralManager, peripheral: CBPeripheral? = nil) {
  832|      1|        cbCentral = central
  833|      1|        cbCentral.delegate = centralProxy
  834|      1|        if let periph = peripheral {
  835|      1|            self.peripheral = Peripheral(periph)
  836|      1|            listenPublisherCancellable = _listenPublisher.connect()
  837|      1|            peripheralStatePublisherCancellable = _peripheralStatePublisher.connect()
  838|      1|            peripheralChangesPublisherCancellable = _peripheralChangesPublisher.connect()
  839|      1|        }
  840|      1|        
  841|      1|    }
  842|       |    
  843|       |    
  844|       |    // MARK: - Private
  845|      1|    private func restore(_ restorer: CentralRestorer) -> Restored {
  846|      1|          // Restore scan if scanning
  847|      1|          if restorer.centralManager.isScanning {
  848|      0|              let restoreDiscoverServices = restorer.services
  849|      0|              let restoreScanOptions = restorer.scanOptions
  850|      0|              let restoreDiscoveryPublisher = self.startDiscovery(withServices: restoreDiscoverServices, options: restoreScanOptions)
  851|      0|              log("[LBT] Scan restore %{public}@",
  852|      0|                  log: OSLog.LittleBT_Log_Restore,
  853|      0|                  type: .debug,
  854|      0|                  arg: restorer.centralManager.isScanning ? "true" : "false")
  855|      0|              return .scan(discoveryPublisher: restoreDiscoveryPublisher)
  856|      1|          }
  857|      1|          if let periph = restorer.peripherals.first, let cbPeripheral = periph.cbPeripheral {
  858|      0|              self.peripheral = Peripheral(cbPeripheral)
  859|      0|              switch cbPeripheral.state {
  860|      0|              case .connected:
  861|      0|                  // If autoconnection was made in background I should receive a callback from connect and the connection state publisher should take care of putting the peripheral in ready. But probably I must connect other connectable
  862|      0|                  self.peripheralChangesPublisherCancellable = self._peripheralChangesPublisher.connect()
  863|      0|                  self.peripheralStatePublisherCancellable = self._peripheralStatePublisher.connect()
  864|      0|                  print("Peripheral already connected")
  865|      0|              case .connecting:
  866|      0|                  // If autoconnection was made in background I should receive a callback from connect and the connection state publisher should take care of putting the peripheral in ready. But probably I must connect other connectable
  867|      0|                  self.peripheralChangesPublisherCancellable = self._peripheralChangesPublisher.connect()
  868|      0|                  self.peripheralStatePublisherCancellable = self._peripheralStatePublisher.connect()
  869|      0|                  print("Peripheral connecting")
  870|      0|              case .disconnected:
  871|      0|                  // A disconnetion event will be sent to the connection event publisher
  872|      0|                  // If a reconection handler is set it will dispatch a new connection
  873|      0|                  self.peripheralStatePublisherCancellable = self._peripheralStatePublisher.connect()
  874|      0|                  print("Peripheral disconnected")
  875|      0|              case .disconnecting:
  876|      0|                  // A disconnetion event will be sent to the connection event publisher
  877|      0|                  // If a reconection handler is set it will dispatch a new connection
  878|      0|                  self.peripheralStatePublisherCancellable = self._peripheralStatePublisher.connect()
  879|      0|
  880|      0|                  print("Peripheral disconnecting")
  881|      0|              @unknown default:
  882|      0|                  fatalError("Connection event in default not handled")
  883|      0|              }
  884|      0|              log("[LBT] Periph restore %{public}@, has delegate: %{public}@ state %{public}d",
  885|      0|                  log: OSLog.LittleBT_Log_Restore,
  886|      0|                  type: .debug,
  887|      0|                  arg: cbPeripheral.description,
  888|      0|                  cbPeripheral.delegate != nil ? "true" : "false",
  889|      0|                  cbPeripheral.state.rawValue)
  890|      0|              return Restored.peripheral(self.peripheral!)
  891|      1|          }
  892|      1|          return Restored.nothing
  893|      1|      }
  894|       |    
  895|    142|    private func ensureBluetoothState() -> AnyPublisher<BluetoothState, LittleBluetoothError> {
  896|    142|
  897|    142|        let futKey = UUID()
  898|    142|        let future = Deferred {
  899|    142|            Future<BluetoothState, LittleBluetoothError> { [unowned self] prom in
  900|    142|                self.centralProxy.centralStatePublisher
  901|    142|                .customPrint("[LBT] CentralStatePublisher", isEnabled: isLogEnabled)
  902|    279|                .tryFilter { [unowned self] (state) -> Bool in
  903|    279|                    switch state {
  904|    279|                    case .poweredOff:
  905|      7|                        if let periph = self.peripheral {
  906|      6|                            let connEvent = ConnectionEvent.disconnected(periph.cbPeripheral, error: .bluetoothPoweredOff)
  907|      6|                            self.centralProxy.connectionEventPublisher.send(connEvent)
  908|      7|                        }
  909|      7|                        throw LittleBluetoothError.bluetoothPoweredOff
  910|    279|                    case .unauthorized:
  911|      0|                        throw LittleBluetoothError.bluetoothUnauthorized
  912|    279|                    case .unsupported:
  913|      0|                        throw LittleBluetoothError.bluetoothUnsupported
  914|    279|                    case .unknown, .resetting:
  915|     40|                        return false
  916|    279|                    case .poweredOn:
  917|    232|                        return true
  918|    279|                    }
  919|    279|                }
  920|    142|                .mapError { (error) -> LittleBluetoothError in
  921|      7|                    error as! LittleBluetoothError
  922|      7|                }
  923|    232|                .map { state -> BluetoothState in
  924|    232|//                    print("CBManager state: \(state)")
  925|    232|                    return state
  926|    232|                }
  927|    142|                .sink(receiveCompletion: { [unowned self, futKey] (completion) in
  928|      7|                    switch completion {
  929|      7|                    case .finished:
  930|      0|                        break
  931|      7|                    case .failure(let error):
  932|      7|                        prom(.failure(error))
  933|      7|                        self.removeAndCancelSubscriber(for: futKey)
  934|      7|                    }
  935|    232|                }) { [unowned self] (state) in
  936|    232|                    prom(.success(state))
  937|    232|                    self.removeAndCancelSubscriber(for: futKey)
  938|    232|                }
  939|    142|                .store(in: &self.disposeBag, for: futKey)
  940|    142|            }
  941|    142|        }
  942|    142|        return future.eraseToAnyPublisher()
  943|    142|
  944|    142|    }
  945|       |   
  946|     67|    private func ensurePeripheralReady() -> AnyPublisher<Peripheral, LittleBluetoothError> {
  947|     67|        guard let periph = peripheral, periph.state == .connected else {
  948|      0|            let state = peripheral?.state
  949|      0|            return Result<Peripheral, LittleBluetoothError>.Publisher(.failure(.peripheralNotConnected(state: state ?? .disconnected))).eraseToAnyPublisher()
  950|     67|        }
  951|     67|        
  952|     67|        return self.centralProxy.connectionEventPublisher
  953|     67|        .customPrint("[LBT] EnsurePeripheralReadyPublisher", isEnabled: isLogEnabled)
  954|     73|        .tryFilter { (event) -> Bool in
  955|     73|            switch event {
  956|     73|            case .disconnected(_, let error?):
  957|      6|                throw error
  958|     73|            case .disconnected(let periph, _):
  959|     35|                throw LittleBluetoothError.peripheralDisconnected(PeripheralIdentifier(peripheral: periph), nil)
  960|     73|            case .autoConnected(_),
  961|      0|                 .connected(_),
  962|      0|                 .connectionFailed(_, _),
  963|      0|                 .notReady(_, _):
  964|      0|                return false
  965|     73|            case .ready(_):
  966|     32|                return true
  967|     73|            }
  968|     73|        }
  969|     67|        .map { [unowned self] (_) -> Peripheral in
  970|     32|            return self.peripheral!
  971|     32|        }
  972|     67|        .mapError { (error) -> LittleBluetoothError in
  973|     41|            error as! LittleBluetoothError
  974|     41|        }
  975|     67|        .merge(with: Just(periph).setFailureType(to: LittleBluetoothError.self))
  976|     67|
  977|     67|        .eraseToAnyPublisher()
  978|     67|    }
  979|       |    
  980|    332|    private func removeAndCancelSubscriber(for key: UUID) {
  981|    332|        let sub = disposeBag[key]
  982|    332|        sub?.cancel()
  983|    332|        disposeBag.removeValue(forKey: key)
  984|    332|    }
  985|       |    
  986|     41|    private func cleanUpForDisconnection() {
  987|     41|        listenPublisherCancellable?.cancel()
  988|     41|        listenPublisherCancellable = nil
  989|     41|        _listenPublisher_ = nil
  990|     41|//        peripheralStatePublisherCancellable?.cancel()
  991|     41|//        peripheralStatePublisherCancellable = nil
  992|     41|//        _peripheralStatePublisher_ = nil
  993|     41|        peripheralChangesPublisherCancellable?.cancel()
  994|     41|        peripheralChangesPublisherCancellable = nil
  995|     41|        _peripheralChangesPublisher_ = nil
  996|     41|        peripheral = nil
  997|     41|    }
  998|       |    
  999|      3|    private func cleanUpForExtraction() {
 1000|      3|        cbCentral.stopScan()
 1001|      3|        scanning?.cancel()
 1002|      3|        scanning = nil
 1003|      3|        cleanUpForDisconnection()
 1004|      3|    }
 1005|       |    
 1006|       |}
 1007|       |
 1008|       |extension LittleBlueTooth: Loggable {}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMCentralManagerDelegate.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |public protocol CBMCentralManagerDelegate: class {
   34|       |
   35|       |    /// Invoked whenever the central manager's state has been updated. Commands
   36|       |    /// should only be issued when the state is `.poweredOn`.
   37|       |    /// A state below`.poweredOn` implies that scanning has stopped and any
   38|       |    /// connected peripherals have been disconnected. If the state moves below
   39|       |    /// `.poweredOff`, all `CBMPeripheral` objects obtained from this central
   40|       |    /// manager become invalid and must be retrieved or discovered again.
   41|       |    /// - Parameter central: The central manager whose state has changed.
   42|       |    func centralManagerDidUpdateState(_ central: CBMCentralManager)
   43|       |    
   44|       |    /// For apps that opt-in to state preservation and restoration, this is the
   45|       |    /// first method invoked when your app is relaunched into the background to
   46|       |    /// complete some Bluetooth-related task. Use this method to synchronize your
   47|       |    /// app's state with the state of the Bluetooth system.
   48|       |    ///
   49|       |    /// When mocking is enabled, the returned state is obtained using
   50|       |    /// `simulateStateRestoration(forIdentifierKey:)`.
   51|       |    /// - Parameters:
   52|       |    ///   - central: The central manager providing this information.
   53|       |    ///   - dict: A dictionary containing information about central that was
   54|       |    ///           preserved by the system at the time the app was terminated.
   55|       |    func centralManager(_ central: CBMCentralManager,
   56|       |                        willRestoreState dict: [String : Any])
   57|       |    
   58|       |    /// This method is invoked while scanning, upon the discovery of peripheral by
   59|       |    /// central. A discovered peripheral must be retained in order to use it;
   60|       |    /// otherwise, it is assumed to not be of interest and will be cleaned up by
   61|       |    /// the central manager. For a list of advertisementData keys, see
   62|       |    /// `CBAdvertisementDataLocalNameKey` and other similar constants.
   63|       |    /// - Parameters:
   64|       |    ///   - central: The central manager providing this update.
   65|       |    ///   - peripheral: A `CBMPeripheral` object.
   66|       |    ///   - advertisementData: A dictionary containing any advertisement and scan
   67|       |    ///                        response data.
   68|       |    ///   - RSSI: The current RSSI of peripheral, in dBm. A value of 127 is
   69|       |    ///           reserved and indicates the RSSI was not available.
   70|       |    func centralManager(_ central: CBMCentralManager,
   71|       |                        didDiscover peripheral: CBMPeripheral,
   72|       |                        advertisementData: [String : Any],
   73|       |                        rssi RSSI: NSNumber)
   74|       |    
   75|       |    /// This method is invoked when a connection initiated by `connect(:options:)`
   76|       |    /// has succeeded.
   77|       |    /// - Parameters:
   78|       |    ///   - central: The central manager providing this information.
   79|       |    ///   - peripheral: The `CBMPeripheral` that has connected.
   80|       |    func centralManager(_ central: CBMCentralManager,
   81|       |                        didConnect peripheral: CBMPeripheral)
   82|       |    
   83|       |    /// This method is invoked when a connection initiated by `connect(:options:)`
   84|       |    /// has failed to complete. As connection attempts do not timeout, the failure
   85|       |    /// of a connection is atypical and usually indicative of a transient issue.
   86|       |    /// - Parameters:
   87|       |    ///   - central: The central manager providing this information.
   88|       |    ///   - peripheral: The `CBMPeripheral` that has failed to connect.
   89|       |    ///   - error: The cause of the failure.
   90|       |    func centralManager(_ central: CBMCentralManager,
   91|       |                        didFailToConnect peripheral: CBMPeripheral,
   92|       |                        error: Error?)
   93|       |    
   94|       |    /// This method is invoked upon the disconnection of a peripheral that was
   95|       |    /// connected by `connect(:options:)`. If the disconnection was not initiated
   96|       |    /// by `cancelPeripheralConnection(:)`, the cause will be detailed in the
   97|       |    /// error parameter. Once this method has been called, no more methods will be
   98|       |    /// invoked on peripheral's `CBMPeripheralDelegate`.
   99|       |    /// - Parameters:
  100|       |    ///   - central: The central manager providing this information.
  101|       |    ///   - peripheral: The `CBMPeripheral` that has disconnected.
  102|       |    ///   - error: If an error occurred, the cause of the failure.
  103|       |    func centralManager(_ central: CBMCentralManager,
  104|       |                        didDisconnectPeripheral peripheral: CBMPeripheral,
  105|       |                        error: Error?)
  106|       |    
  107|       |    /// This method is invoked upon the connection or disconnection of a
  108|       |    /// peripheral that matches any of the options provided in
  109|       |    /// `registerForConnectionEvents(options:)`.
  110|       |    /// - Parameters:
  111|       |    ///   - central: The central manager providing this information.
  112|       |    ///   - event: The `CBConnectionEvent` that has occurred.
  113|       |    ///   - peripheral: The `CBMPeripheral` that caused the event.
  114|       |    @available(iOS 13.0, *)
  115|       |    func centralManager(_ central: CBMCentralManager,
  116|       |                        connectionEventDidOccur event: CBMConnectionEvent,
  117|       |                        for peripheral: CBMPeripheral)
  118|       |    
  119|       |    /// This method is invoked when the authorization status changes for a
  120|       |    /// peripheral connected with `connect(:options:)` option
  121|       |    /// `CBConnectPeripheralOptionRequiresANCS`.
  122|       |    ///
  123|       |    /// - Important: This method is not implemented in mock central manager.
  124|       |    /// - Parameters:
  125|       |    ///   - central: The central manager providing this information.
  126|       |    ///   - peripheral: The `CBMPeripheral` that caused the event.
  127|       |    @available(iOS 13.0, *)
  128|       |    func centralManager(_ central: CBMCentralManager,
  129|       |                        didUpdateANCSAuthorizationFor peripheral: CBMPeripheral)
  130|       |}
  131|       |
  132|       |public extension CBMCentralManagerDelegate {
  133|       |    
  134|       |    func centralManager(_ central: CBMCentralManager,
  135|      0|                        willRestoreState dict: [String : Any]) {
  136|      0|        // optional method
  137|      0|    }
  138|       |    
  139|       |    func centralManager(_ central: CBMCentralManager,
  140|       |                        didDiscover peripheral: CBMPeripheral,
  141|       |                        advertisementData: [String : Any],
  142|      0|                        rssi RSSI: NSNumber) {
  143|      0|        // optional method
  144|      0|    }
  145|       |    
  146|       |    func centralManager(_ central: CBMCentralManager,
  147|      0|                        didConnect peripheral: CBMPeripheral) {
  148|      0|        // optional method
  149|      0|    }
  150|       |    
  151|       |    func centralManager(_ central: CBMCentralManager,
  152|       |                        didFailToConnect peripheral: CBMPeripheral,
  153|      0|                        error: Error?) {
  154|      0|        // optional method
  155|      0|    }
  156|       |    
  157|       |    func centralManager(_ central: CBMCentralManager,
  158|       |                        didDisconnectPeripheral peripheral: CBMPeripheral,
  159|      0|                        error: Error?) {
  160|      0|        // optional method
  161|      0|    }
  162|       |    
  163|       |    @available(iOS 13.0, *)
  164|       |    func centralManager(_ central: CBMCentralManager,
  165|       |                        connectionEventDidOccur event: CBMConnectionEvent,
  166|      0|                        for peripheral: CBMPeripheral) {
  167|      0|        // optional method
  168|      0|    }
  169|       |    
  170|       |    @available(iOS 13.0, *)
  171|       |    func centralManager(_ central: CBMCentralManager,
  172|      0|                        didUpdateANCSAuthorizationFor peripheral: CBMPeripheral) {
  173|      0|        // optional method
  174|      0|    }
  175|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMCentralManagerFactory.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |/// The factory that instantiates the `CBMCentralManager` object.
   34|       |/// The factory may be used to automatically instantiate either a native
   35|       |/// or mock implementation based on the environment. You may also
   36|       |/// instantiate the `CBMCentralManagerMock` or `CBMCentralManagerNative` without
   37|       |/// using this factory.
   38|       |public class CBMCentralManagerFactory {
   39|       |    
   40|       |    /// This simulation method is called when a mock central manager was
   41|       |    /// created with an option to restore the state
   42|       |    /// (`CBMCentralManagerOptionRestoreIdentifierKey`).
   43|       |    ///
   44|       |    /// The returned map, if not <i>nil</i>, will be passed to
   45|       |    /// `centralManager(:willRestoreState:)` before creation.
   46|       |    /// - SeeAlso: CBMCentralManagerRestoredStatePeripheralsKey
   47|       |    /// - SeeAlso: CBMCentralManagerRestoredStateScanServicesKey
   48|       |    /// - SeeAlso: CBMCentralManagerRestoredStateScanOptionsKey
   49|       |    public static var simulateStateRestoration: ((_ identifierKey: String) -> [String : Any]?)?
   50|       |    
   51|       |    /// Returns a boolean value representing the support for the provided features.
   52|       |    ///
   53|       |    /// This method will be called when `supports(:)` method is called.
   54|       |    #if !os(macOS)
   55|       |    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
   56|       |    public static var simulateFeaturesSupport: ((_ features: CBMCentralManager.Feature) -> Bool)?
   57|       |    #endif
   58|       |    
   59|       |    /// Returns the implementation of `CBCentralManager`, depending on the environment.
   60|       |    /// On a simulator, or when the `forceMock` flag is enabled, the mock
   61|       |    /// implementation is returned, otherwise the native one.
   62|       |    /// - Parameters:
   63|       |    ///   - forceMock: A flag to force mocking also on physical device.
   64|       |    /// - Returns: The implementation of `CBCentralManager`.
   65|      0|    public static func instance(forceMock: Bool = false) -> CBMCentralManager {
   66|      0|        #if targetEnvironment(simulator)
   67|      0|            return CBMCentralManagerMock()
   68|      0|        #else
   69|      0|            return forceMock ?
   70|      0|                CBMCentralManagerMock() :
   71|      0|                CBMCentralManagerNative()
   72|      0|        #endif
   73|      0|    }
   74|       |    
   75|       |    /// Returns the implementation of `CBCentralManager`, depending on the environment.
   76|       |    /// On a simulator, or when the `forceMock` flag is enabled, the mock
   77|       |    /// implementation is returned, otherwise the native one.
   78|       |    /// - Parameters:
   79|       |    ///   - delegate: The delegate that will receive central role events.
   80|       |    ///   - queue: The dispatch queue on which the events will be dispatched.
   81|       |    ///            If <i>nil</i>, the main queue will be used.
   82|       |    ///   - forceMock: A flag to force mocking also on a physical device.
   83|       |    /// - Returns: The implementation of `CBCentralManager`.
   84|       |    public static func instance(delegate: CBMCentralManagerDelegate?,
   85|       |                                queue: DispatchQueue?,
   86|      0|                                forceMock: Bool = false) -> CBMCentralManager {
   87|      0|        #if targetEnvironment(simulator)
   88|      0|            return CBMCentralManagerMock(delegate: delegate, queue: queue)
   89|      0|        #else
   90|      0|            return forceMock ?
   91|      0|                CBMCentralManagerMock(delegate: delegate, queue: queue) :
   92|      0|                CBMCentralManagerNative(delegate: delegate, queue: queue)
   93|      0|        #endif
   94|      0|    }
   95|       |    
   96|       |    /// Returns the implementation of `CBCentralManager`, depending on the environment.
   97|       |    /// On a simulator, or when the `forceMock` flag is enabled, the mock
   98|       |    /// implementation is returned, otherwise the native one.
   99|       |    /// - Parameters:
  100|       |    ///   - delegate: The delegate that will receive central role events.
  101|       |    ///   - queue: The dispatch queue on which the events will be dispatched.
  102|       |    ///            If <i>nil</i>, the main queue will be used.
  103|       |    ///   - options: An optional dictionary specifying options for the manager.
  104|       |    ///   - forceMock: A flag to force mocking also on a physical device.
  105|       |    /// - Returns: The implementation of `CBCentralManager`.
  106|       |    public static func instance(delegate: CBMCentralManagerDelegate?,
  107|       |                                queue: DispatchQueue?,
  108|       |                                options: [String : Any]?,
  109|     45|                                forceMock: Bool = false) -> CBMCentralManager {
  110|     45|        #if targetEnvironment(simulator)
  111|     45|            return CBMCentralManagerMock(delegate: delegate, queue: queue, options: options)
  112|     45|        #else
  113|     45|            return forceMock ?
  114|     45|                CBMCentralManagerMock(delegate: delegate, queue: queue, options: options) :
  115|     45|                CBMCentralManagerNative(delegate: delegate, queue: queue, options: options)
  116|     45|        #endif
  117|     45|    }
  118|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMCentralManagerMock.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |open class CBMCentralManagerMock: NSObject, CBMCentralManager {
   34|       |    /// Mock RSSI deviation.
   35|       |    ///
   36|       |    /// Returned RSSI values will be in range
   37|       |    /// `(base RSSI - deviation)...(base RSSI + deviation)`.
   38|       |    fileprivate static let rssiDeviation = 15 // dBm
   39|       |    
   40|       |    /// A list of all mock managers instantiated by user.
   41|       |    private static var managers: [WeakRef<CBMCentralManagerMock>] = []
   42|       |    /// A list of peripherals known to the system.
   43|       |    private static var peripherals: [CBMPeripheralSpec] = []
   44|       |    /// The global state of the Bluetooth adapter on the device.
   45|       |    fileprivate private(set) static var managerState: CBMManagerState = .poweredOff {
   46|     43|        didSet {
   47|     43|            // For all existing managers...
   48|     43|            managers
   49|    881|                .compactMap { $0.ref }
   50|    881|                .forEach { manager in
   51|    881|                    // ...stop scanning if state changed to any other state
   52|    881|                    // than `.poweredOn`. Also, forget all peripherals.
   53|    881|                    if managerState != .poweredOn {
   54|     61|                        manager.isScanning = false
   55|     61|                        manager.scanFilter = nil
   56|     61|                        manager.scanOptions = nil
   57|     61|                        manager.peripherals.values.forEach { $0.managerPoweredOff() }
   58|     61|                        manager.peripherals.removeAll()
   59|    881|                    }
   60|    881|                    // ...and notify delegate.
   61|    881|                    manager.queue.async {
   62|    881|                        manager.delegate?.centralManagerDidUpdateState(manager)
   63|    881|                    }
   64|    881|                }
   65|     43|            // Compact the list, if any of managers were disposed.
   66|    881|            managers.removeAll { $0.ref == nil }
   67|     43|        }
   68|       |    }
   69|       |    
   70|       |    open weak var delegate: CBMCentralManagerDelegate?
   71|  2.01k|    open var state: CBMManagerState {
   72|  2.01k|        return initialized ? CBMCentralManagerMock.managerState : .unknown
   73|  2.01k|    }
   74|       |    open private(set) var isScanning: Bool
   75|       |    private var scanFilter: [CBMUUID]?
   76|       |    private var scanOptions: [String : Any]?
   77|       |
   78|       |    /// The dispatch queue used for all callbacks.
   79|       |    fileprivate let queue: DispatchQueue
   80|       |    /// A map of peripherals known to this central manager.
   81|     45|    private var peripherals: [UUID : CBMPeripheralMock] = [:]
   82|       |    /// A flag set to true few milliseconds after the manager is created.
   83|       |    /// Some features, like the state or retrieving peripherals are not
   84|       |    /// available when manager hasn't been initialized yet.
   85|  2.01k|    private var initialized: Bool {
   86|  2.01k|        // This method returns true if the manager is added to
   87|  2.01k|        // the list of managers.
   88|  2.01k|        // Calling tearDownSimulation() will remove all managers
   89|  2.01k|        // from that list, making them uninitialized again.
   90|  30.1k|        return CBMCentralManagerMock.managers.contains { $0.ref == self }
   91|  2.01k|    }
   92|       |    
   93|       |    // MARK: - Initializers
   94|       |    
   95|      0|    public required override init() {
   96|      0|        self.isScanning = false
   97|      0|        self.queue = DispatchQueue.main
   98|      0|        super.init()
   99|      0|        initialize()
  100|      0|    }
  101|       |    
  102|       |    public required init(delegate: CBMCentralManagerDelegate?,
  103|      0|                         queue: DispatchQueue?) {
  104|      0|        self.isScanning = false
  105|      0|        self.queue = queue ?? DispatchQueue.main
  106|      0|        self.delegate = delegate
  107|      0|        super.init()
  108|      0|        initialize()
  109|      0|    }
  110|       |    
  111|       |    @available(iOS 7.0, *)
  112|       |    public required init(delegate: CBMCentralManagerDelegate?,
  113|       |                         queue: DispatchQueue?,
  114|     45|                         options: [String : Any]?) {
  115|     45|        self.isScanning = false
  116|     45|        self.queue = queue ?? DispatchQueue.main
  117|     45|        self.delegate = delegate
  118|     45|        super.init()
  119|     45|        if let options = options,
  120|     45|           let identifierKey = options[CBMCentralManagerOptionRestoreIdentifierKey] as? String,
  121|     45|           let dict = CBMCentralManagerFactory
  122|     45|               .simulateStateRestoration?(identifierKey) {
  123|      1|            var state: [String : Any] = [:]
  124|      1|            if let peripheralKeys = dict[CBMCentralManagerRestoredStatePeripheralsKey] {
  125|      1|                state[CBMCentralManagerRestoredStatePeripheralsKey] = peripheralKeys
  126|      1|            }
  127|      1|            if let scanServiceKey = dict[CBMCentralManagerRestoredStateScanServicesKey] {
  128|      1|                state[CBMCentralManagerRestoredStateScanServicesKey] = scanServiceKey
  129|      1|            }
  130|      1|            if let scanOptions = dict[CBMCentralManagerRestoredStateScanOptionsKey] {
  131|      1|                state[CBMCentralManagerRestoredStateScanOptionsKey] = scanOptions
  132|      1|            }
  133|      1|            delegate?.centralManager(self, willRestoreState: state)
  134|     45|        }
  135|     45|        initialize()
  136|     45|    }
  137|       |    
  138|     45|    private func initialize() {
  139|     45|        if CBMCentralManagerMock.managerState == .poweredOn &&
  140|     45|           CBMCentralManagerMock.peripherals.isEmpty {
  141|      0|            NSLog("Warning: No simulated peripherals. " +
  142|      0|                  "Call simulatePeripherals(:) before creating central manager")
  143|     45|        }
  144|     45|        // Let's say initialization takes 10 ms. Less or more.
  145|     45|        queue.asyncAfter(deadline: .now() + .milliseconds(10)) { [weak self] in
  146|     45|            if let self = self {
  147|     42|                CBMCentralManagerMock.managers.append(WeakRef(self))
  148|     42|                self.delegate?.centralManagerDidUpdateState(self)
  149|     45|            }
  150|     45|        }
  151|     45|    }
  152|       |    
  153|       |    /// Removes all active central manager instances and peripherals from the
  154|       |    /// simulation, resetting it to the initial state.
  155|       |    ///
  156|       |    /// Use this to tear down your mocks between tests, e.g. in `tearDownWithError()`.
  157|       |    /// All manager delegates will receive a `.unknown` state update.
  158|      0|    public static func tearDownSimulation() {
  159|      0|        // Set the state of all currently existing cenral manager instances to
  160|      0|        // .unknown, which will make them invalid.
  161|      0|        managerState = .unknown
  162|      0|        // Remove all central manager instances.
  163|      0|        managers.removeAll()
  164|      0|        // Set the manager state to powered Off.
  165|      0|        managerState = .poweredOff
  166|      0|        peripherals.removeAll()
  167|      0|    }
  168|       |    
  169|       |    // MARK: - Central manager simulation methods
  170|       |    
  171|       |    /// Sets the initial state of the Bluetooth central manager.
  172|       |    ///
  173|       |    /// This method should only be called ones, before any central manager
  174|       |    /// is created. By default, the initial state is `.poweredOff`.
  175|       |    /// - Parameter state: The initial state of the central manager.
  176|     43|    public static func simulateInitialState(_ state: CBMManagerState) {
  177|     43|        managerState = state
  178|     43|    }
  179|       |    
  180|       |    /// This method sets a list of simulated peripherals.
  181|       |    ///
  182|       |    /// Peripherals added using this method will be available for scanning
  183|       |    /// and connecting, depending on their proximity. Use peripheral's
  184|       |    /// `simulateProximity(of:didChangeTo:)` to modify proximity.
  185|       |    ///
  186|       |    /// This method may only be called before any central manager was created
  187|       |    /// or when Bluetooth state is `.poweredOff`. Existing list of peripherals
  188|       |    /// will be overritten.
  189|       |    /// - Parameter peripherals: Peripherals specifications.
  190|      1|    public static func simulatePeripherals(_ peripherals: [CBMPeripheralSpec]) {
  191|      1|        guard managers.isEmpty || managerState == .poweredOff else {
  192|      0|            NSLog("Warning: Peripherals can not be added while the simulation is running. " +
  193|      0|                  "Add peripherals before getting any central manager instance, " +
  194|      0|                  "or when manager is powered off.")
  195|      0|            return
  196|      1|        }
  197|      1|        CBMCentralManagerMock.peripherals = peripherals
  198|      1|    }
  199|       |    
  200|       |    /// Simulates turning the Bluetooth adapter on.
  201|      0|    public static func simulatePowerOn() {
  202|      0|        guard managerState != .poweredOn else {
  203|      0|            return
  204|      0|        }
  205|      0|        managerState = .poweredOn
  206|      0|    }
  207|       |    
  208|       |    /// Simulate turning the Bluetooth adapter off.
  209|      0|    public static func simulatePowerOff() {
  210|      0|        guard managerState != .poweredOff else {
  211|      0|            return
  212|      0|        }
  213|      0|        managerState = .poweredOff
  214|      0|    }
  215|       |    
  216|       |    // MARK: - Peripheral simulation methods
  217|       |    
  218|       |    /// Simulates a situation when the given peripheral was moved closer
  219|       |    /// or away from the phone.
  220|       |    ///
  221|       |    /// If the proximity is changed to `.outOfRange`, the peripheral will
  222|       |    /// be disconnected and will not appear on scan results.
  223|       |    /// - Parameter peripheral: The peripheral that was repositioned.
  224|       |    /// - Parameter proximity: The new peripheral proximity.
  225|       |    internal static func proximity(of peripheral: CBMPeripheralSpec,
  226|     47|                                   didChangeTo proximity: CBMProximity) {
  227|     47|        guard peripheral.proximity != proximity else {
  228|     34|            return
  229|     34|        }
  230|     13|        // Is the peripheral simulated?
  231|     13|        guard peripherals.contains(peripheral) else {
  232|      0|            return
  233|     13|        }
  234|     13|        peripheral.proximity = proximity
  235|     13|        
  236|     13|        if proximity == .outOfRange {
  237|      4|            self.peripheral(peripheral,
  238|      4|                            didDisconnectWithError: CBMError(.connectionTimeout))
  239|     13|        } else {
  240|      9|            self.peripheralBecameAvailable(peripheral)
  241|     13|        }
  242|     13|    }
  243|       |    
  244|       |    /// Simulates a situation when the device changes its services.
  245|       |    /// - Parameters:
  246|       |    ///   - peripheral: The peripheral that changed services.
  247|       |    ///   - newName: New device name.
  248|       |    ///   - newServices: New list of device services.
  249|       |    internal static func peripheral(_ peripheral: CBMPeripheralSpec,
  250|       |                                    didUpdateName newName: String?,
  251|      1|                                    andServices newServices: [CBMServiceMock]) {
  252|      1|        // Is the peripheral simulated?
  253|      1|        guard peripherals.contains(peripheral) else {
  254|      0|            return
  255|      1|        }
  256|      1|        peripheral.services = newServices
  257|      1|
  258|      1|        guard peripheral.virtualConnections > 0 else {
  259|      0|            return
  260|      1|        }
  261|      2|        let existingManagers = managers.compactMap { $0.ref }
  262|      1|        existingManagers.forEach { manager in
  263|      1|            manager.peripherals[peripheral.identifier]?
  264|      1|                .notifyServicesChanged()
  265|      1|        }
  266|      1|        // Notify that the name has changed.
  267|      1|        if peripheral.name != newName {
  268|      1|            peripheral.name = newName
  269|      1|            existingManagers.forEach { manager in
  270|      1|                // TODO: This needs to be verified.
  271|      1|                //       Should a local peripheral copy be created if no such?
  272|      1|                //       Are all central managers notified about any device
  273|      1|                //       changing name?
  274|      1|                manager.peripherals[peripheral.identifier]?
  275|      1|                    .notifyNameChanged()
  276|      1|            }
  277|      1|        }
  278|      1|    }
  279|       |    
  280|       |    /// Simulates a notification sent from the peripheral.
  281|       |    ///
  282|       |    /// All central managers that have enabled notifications on it
  283|       |    /// will receive `peripheral(:didUpdateValueFor:error)`.
  284|       |    /// - Parameter characteristic: The characteristic from which
  285|       |    ///                             notification is to be sent.
  286|       |    internal static func peripheral(_ peripheral: CBMPeripheralSpec,
  287|    235|                                    didUpdateValueFor characteristic: CBMCharacteristicMock) {
  288|    235|        // Is the peripheral simulated?
  289|    235|        guard peripherals.contains(peripheral) else {
  290|      0|            return
  291|    235|        }
  292|    235|        guard peripheral.virtualConnections > 0 else {
  293|     38|            return
  294|    197|        }
  295|    197|        managers
  296|  4.68k|            .compactMap { $0.ref }
  297|    197|            .forEach { manager in
  298|    197|                manager.peripherals[peripheral.identifier]?
  299|    197|                    .notifyValueChanged(for: characteristic)
  300|    197|            }
  301|    197|    }
  302|       |    
  303|       |    /// This method simulates a new virtual connection to the given
  304|       |    /// peripheral, as if some other application connected to it.
  305|       |    ///
  306|       |    /// Central managers will not be notified about the state change unless
  307|       |    /// they registered for connection events using
  308|       |    /// `registerForConnectionEvents(options:)`.
  309|       |    /// Even without registering (which is available since iOS 13), they
  310|       |    /// can retrieve the connected peripheral using
  311|       |    /// `retrieveConnectedPeripherals(withServices:)`.
  312|       |    ///
  313|       |    /// The peripheral does not need to be registered before.
  314|       |    /// - Parameter peripheral: The peripheral that has connected.
  315|      0|    internal static func peripheralDidConnect(_ peripheral: CBMPeripheralSpec) {
  316|      0|        // Is the peripheral simulated?
  317|      0|        guard peripherals.contains(peripheral) else {
  318|      0|            return
  319|      0|        }
  320|      0|        peripheral.virtualConnections += 1
  321|      0|        
  322|      0|        // TODO: notify a user registered for connection events
  323|      0|    }
  324|       |    
  325|       |    /// Method called when a peripheral becomes available (in range).
  326|       |    /// If there is a pending connection request, it will connect.
  327|       |    /// - Parameter peripheral: The peripheral that came in range. 
  328|      9|    internal static func peripheralBecameAvailable(_ peripheral: CBMPeripheralSpec) {
  329|      9|        // Is the peripheral simulated?
  330|      9|        guard peripherals.contains(peripheral) else {
  331|      0|            return
  332|      9|        }
  333|      9|        managers
  334|    141|            .compactMap { $0.ref }
  335|    141|            .forEach { manager in
  336|    141|                if let target = manager.peripherals[peripheral.identifier],
  337|    141|                   target.state == .connecting {
  338|      0|                    target.connect() { result in
  339|      0|                        switch result {
  340|      0|                        case .success:
  341|      0|                            manager.delegate?.centralManager(manager, didConnect: target)
  342|      0|                        case .failure(let error):
  343|      0|                            manager.delegate?.centralManager(manager, didFailToConnect: target,
  344|      0|                                                             error: error)
  345|      0|                        }
  346|      0|                    }
  347|    141|                }
  348|    141|            }
  349|      9|    }
  350|       |    
  351|       |    /// Simulates the peripheral to disconnect from the device.
  352|       |    /// All connected mock central managers will receive
  353|       |    /// `peripheral(:didDisconnected:error)` callback.
  354|       |    /// - Parameter peripheral: The peripheral to disconnect.
  355|       |    /// - Parameter error: The disconnection reason. Use `CBError` or
  356|       |    ///                    `CBATTError` errors.
  357|       |    internal static func peripheral(_ peripheral: CBMPeripheralSpec,
  358|     11|                                    didDisconnectWithError error: Error =  CBError(.peripheralDisconnected)) {
  359|     11|        // Is the device connected at all?
  360|     11|        guard peripheral.isConnected else {
  361|      7|            return
  362|      7|        }
  363|      4|        // Is the peripheral simulated?
  364|      4|        guard peripherals.contains(peripheral) else {
  365|      0|            return
  366|      4|        }
  367|      4|        // The device has disconnected, so it can start advertising
  368|      4|        // immediately.
  369|      4|        peripheral.virtualConnections = 0
  370|      4|        // Notify all central managers.
  371|      4|        managers
  372|     54|            .compactMap { $0.ref }
  373|     54|            .forEach { manager in
  374|     54|                if let target = manager.peripherals[peripheral.identifier],
  375|     54|                    target.state == .connected {
  376|      4|                    target.disconnected(withError: error) { error in
  377|      4|                        manager.delegate?.centralManager(manager,
  378|      4|                                                         didDisconnectPeripheral: target,
  379|      4|                                                         error: error)
  380|      4|                    }
  381|     54|                }
  382|     54|            }
  383|      4|        // TODO: notify a user registered for connection events
  384|      4|    }
  385|       |    
  386|       |    // MARK: - CBCentralManager mock methods
  387|       |    
  388|       |    #if !os(macOS)
  389|       |    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  390|      0|    public static func supports(_ features: CBMCentralManager.Feature) -> Bool {
  391|      0|        return CBMCentralManagerFactory.simulateFeaturesSupport?(features) ?? false
  392|      0|    }
  393|       |    #endif
  394|       |    
  395|       |    /// This is a Timer callback, that's called to emulate scanning for Bluetooth LE
  396|       |    /// devices. When the `CBCentralManagerScanOptionAllowDuplicatesKey` options
  397|       |    /// was set when scanning was started, the timer will repeat every advertising
  398|       |    /// interval until scanning is stopped.
  399|       |    ///
  400|       |    /// The scanned peripheral is set as `userInfo`.
  401|       |    /// - Parameter timer: The timer that is fired.
  402|    311|    @objc private func notify(timer: Timer) {
  403|    311|        guard let mock = timer.userInfo as? CBMPeripheralSpec,
  404|    311|              let advertisementData = mock.advertisementData,
  405|    311|              isScanning else {
  406|     36|            timer.invalidate()
  407|     36|            return
  408|    275|        }
  409|    275|        guard mock.proximity != .outOfRange else {
  410|    233|            return
  411|    233|        }
  412|     42|        guard !mock.isConnected || mock.isAdvertisingWhenConnected else {
  413|      0|            return
  414|     42|        }
  415|     42|        // Get or create local peripheral instance.
  416|     42|        if peripherals[mock.identifier] == nil {
  417|     42|            peripherals[mock.identifier] = CBMPeripheralMock(basedOn: mock,
  418|     42|                                                             by: self)
  419|     42|        }
  420|     42|        let peripheral = peripherals[mock.identifier]!
  421|     42|        
  422|     42|        // Emulate RSSI based on proximity. Apply some deviation.
  423|     42|        let rssi = mock.proximity.RSSI
  424|     42|        let delta = CBMCentralManagerMock.rssiDeviation
  425|     42|        let deviation = Int.random(in: -delta...delta)
  426|     42|        delegate?.centralManager(self, didDiscover: peripheral,
  427|     42|                                 advertisementData: advertisementData,
  428|     42|                                 rssi: (rssi + deviation) as NSNumber)
  429|     42|        // The first scan result is returned without a name.
  430|     42|        // This flag must then be called after it has been reported.
  431|     42|        // Setting this flag will cause the advertising name to be
  432|     42|        // returned from CBPeripheral.name.
  433|     42|        peripheral.wasScanned = true
  434|     42|        
  435|     42|        let allowDuplicates = scanOptions?[CBMCentralManagerScanOptionAllowDuplicatesKey] as? NSNumber ?? false as NSNumber
  436|     42|        if !allowDuplicates.boolValue {
  437|     42|            timer.invalidate()
  438|     42|        }
  439|     42|    }
  440|       |    
  441|       |    open func scanForPeripherals(withServices serviceUUIDs: [CBMUUID]?,
  442|     39|                                   options: [String : Any]?) {
  443|     39|        // Central manager must be in powered on state.
  444|     39|        guard ensurePoweredOn() else { return }
  445|     39|        if isScanning {
  446|      0|            stopScan()
  447|     39|        }
  448|     39|        isScanning = true
  449|     39|        scanFilter = serviceUUIDs
  450|     39|        scanOptions = options
  451|     39|
  452|     39|        CBMCentralManagerMock.peripherals
  453|     39|            // For all advertising peripherals,
  454|     78|            .filter { $0.advertisementData   != nil
  455|     78|                   && $0.advertisingInterval != nil
  456|     78|                   && $0.advertisingInterval! > 0 }
  457|     78|            .forEach { mock in
  458|     78|                // If no Service UUID was used, or the device matches at least one service,
  459|     78|                // report it to the delegate (call will be delayed using a Timer).
  460|     78|                let services = mock.advertisementData![CBMAdvertisementDataServiceUUIDsKey] as? [CBMUUID]
  461|     78|                if serviceUUIDs == nil ||
  462|     78|                   services?.contains(where: serviceUUIDs!.contains) ?? false {
  ------------------
  | Unexecuted instantiation: $s17CoreBluetoothMock017CBMCentralManagerC0C18scanForPeripherals12withServices7optionsySaySo6CBUUIDCGSg_SDySSypGSgtFyAA17CBMPeripheralSpecCXEfU0_SbyKXEfu_SbAHcAIcfu0_
  ------------------
  | Unexecuted instantiation: $s17CoreBluetoothMock017CBMCentralManagerC0C18scanForPeripherals12withServices7optionsySaySo6CBUUIDCGSg_SDySSypGSgtFyAA17CBMPeripheralSpecCXEfU0_SbyKXEfu_SbAHcAIcfu0_SbAHcfu1_
  ------------------
  463|     78|                    // The timer will be called multiple times, even if
  464|     78|                    // CBCentralManagerScanOptionAllowDuplicatesKey was not set.
  465|     78|                    // In that case, the timer will be invalidated after the
  466|     78|                    // device has been reported for the first time.
  467|     78|                    //
  468|     78|                    // Timer works only on queues with a active run loop.
  469|     78|                    DispatchQueue.main.async {
  470|     78|                        Timer.scheduledTimer(
  471|     78|                            timeInterval: mock.advertisingInterval!,
  472|     78|                            target: self,
  473|     78|                            selector: #selector(self.notify(timer:)),
  474|     78|                            userInfo: mock,
  475|     78|                            repeats: true
  476|     78|                        )
  477|     78|                    }
  478|     78|                }
  479|     78|            }
  480|     39|    }
  481|       |    
  482|     43|    open func stopScan() {
  483|     43|        // Central manager must be in powered on state.
  484|     43|        guard ensurePoweredOn() else { return }
  485|     40|        isScanning = false
  486|     40|        scanFilter = nil
  487|     40|        scanOptions = nil
  488|     40|    }
  489|       |    
  490|       |    open func connect(_ peripheral: CBMPeripheral,
  491|     35|                        options: [String : Any]?) {
  492|     35|        // Central manager must be in powered on state.
  493|     35|        guard ensurePoweredOn() else { return }
  494|     35|        if let o = options, !o.isEmpty {
  495|      0|            NSLog("Warning: Connection options are not supported in mock central manager")
  496|     35|        }
  497|     35|        // Ignore peripherals that are not mocks.
  498|     35|        guard let mock = peripheral as? CBMPeripheralMock else {
  499|      0|            return
  500|     35|        }
  501|     35|        // The peripheral must come from this central manager. Ignore other.
  502|     35|        // To connect a peripheral obtained using another central manager
  503|     35|        // use `retrievePeripherals(withIdentifiers:)` or
  504|     35|        // `retrieveConnectedPeripherals(withServices:)`.
  505|     35|        guard peripherals.values.contains(mock) else {
  506|      0|            return
  507|     35|        }
  508|     35|        mock.connect() { result in
  509|     34|            switch result {
  510|     34|            case .success:
  511|     34|                self.delegate?.centralManager(self, didConnect: mock)
  512|     34|            case .failure(let error):
  513|      0|                self.delegate?.centralManager(self, didFailToConnect: mock,
  514|      0|                                              error: error)
  515|     34|            }
  516|     34|        }
  517|     35|    }
  518|       |    
  519|     31|    open func cancelPeripheralConnection(_ peripheral: CBMPeripheral) {
  520|     31|        // Central manager must be in powered on state.
  521|     31|        guard ensurePoweredOn() else { return }
  522|     31|        // Ignore peripherals that are not mocks.
  523|     31|        guard let mock = peripheral as? CBMPeripheralMock else {
  524|      0|            return
  525|     31|        }
  526|     31|        // It is not possible to cancel connection of a peripheral obtained
  527|     31|        // from another central manager.
  528|     31|        guard peripherals.values.contains(mock) else {
  529|      0|            return
  530|     31|        }
  531|     31|        mock.disconnect() {
  532|     31|            self.delegate?.centralManager(self, didDisconnectPeripheral: mock,
  533|     31|                                          error: nil)
  534|     31|        }
  535|     31|    }
  536|       |    
  537|     38|    open func retrievePeripherals(withIdentifiers identifiers: [UUID]) -> [CBMPeripheral] {
  538|     38|        // Starting from iOS 13, this method returns peripherals only in ON state.
  539|     38|        guard ensurePoweredOn() else { return [] }
  540|     35|        // Get the peripherals already known to this central manager.
  541|     35|        let localPeripherals = peripherals[identifiers]
  542|     35|        // If all were found, return them.
  543|     35|        if localPeripherals.count == identifiers.count {
  544|     35|            return localPeripherals
  545|     35|        }
  546|      0|        let missingIdentifiers = identifiers.filter { peripherals[$0] == nil }
  547|      0|        // Otherwise, we need to look for them among other managers, and
  548|      0|        // copy them to the local manager.
  549|      0|        let peripheralsKnownByOtherManagers = missingIdentifiers
  550|      0|            .flatMap { i in
  551|      0|                CBMCentralManagerMock.managers
  552|      0|                    .compactMap { $0.ref?.peripherals[i] }
  553|      0|            }
  554|      0|            .map { CBMPeripheralMock(copy: $0, by: self) }
  555|      0|        peripheralsKnownByOtherManagers.forEach {
  556|      0|            peripherals[$0.identifier] = $0
  557|      0|        }
  558|      0|        // Return them in the same order as requested, some may be missing.
  559|      0|        return (localPeripherals + peripheralsKnownByOtherManagers)
  560|      0|            .sorted {
  561|      0|                let firstIndex = identifiers.firstIndex(of: $0.identifier)!
  562|      0|                let secondIndex = identifiers.firstIndex(of: $1.identifier)!
  563|      0|                return firstIndex < secondIndex
  564|      0|            }
  565|     35|    }
  566|       |    
  567|      0|    open func retrieveConnectedPeripherals(withServices serviceUUIDs: [CBMUUID]) -> [CBMPeripheral] {
  568|      0|        // Starting from iOS 13, this method returns peripherals only in ON state.
  569|      0|        guard ensurePoweredOn() else { return [] }
  570|      0|        // Get the connected peripherals with at least one of the given services
  571|      0|        // that are already known to this central manager.
  572|      0|        let peripheralsConnectedByThisManager = peripherals[serviceUUIDs]
  573|      0|            .filter { $0.state == .connected }
  574|      0|        // Other central managers may know some connected peripherals that
  575|      0|        // are not known to the local one.
  576|      0|        let peripheralsConnectedByOtherManagers = CBMCentralManagerMock.managers
  577|      0|            // Get only those managers that were not disposed.
  578|      0|            .filter { $0.ref != nil }
  579|      0|            // Look for connected peripherals known to other managers.
  580|      0|            .flatMap {
  581|      0|                $0.ref!.peripherals[serviceUUIDs]
  582|      0|                    .filter { $0.state == .connected }
  583|      0|            }
  584|      0|            // Search for ones that are not known to the local manager.
  585|      0|            .filter { peripherals[$0.identifier] == nil }
  586|      0|            // Create a local copy.
  587|      0|            .map { CBMPeripheralMock(copy: $0, by: self) }
  588|      0|        // Add those copies to the local manager.
  589|      0|        peripheralsConnectedByOtherManagers.forEach {
  590|      0|            peripherals[$0.identifier] = $0
  591|      0|        }
  592|      0|        let peripheralsConnectedByOtherApps = CBMCentralManagerMock.peripherals
  593|      0|            .filter { $0.isConnected }
  594|      0|            // Search for ones that are not known to the local manager.
  595|      0|            .filter { peripherals[$0.identifier] == nil }
  596|      0|            // And only those that match any of given service UUIDs.
  597|      0|            .filter {
  598|      0|                $0.services!.contains { service in
  599|      0|                    serviceUUIDs.contains(service.uuid)
  600|      0|                }
  601|      0|            }
  602|      0|            // Create a local copy.
  603|      0|            .map { CBMPeripheralMock(basedOn: $0, by: self) }
  604|      0|        return peripheralsConnectedByThisManager
  605|      0|             + peripheralsConnectedByOtherManagers
  606|      0|             + peripheralsConnectedByOtherApps
  607|      0|    }
  608|       |    
  609|       |    @available(iOS 13.0, *)
  610|      0|    open func registerForConnectionEvents(options: [CBMConnectionEventMatchingOption : Any]?) {
  611|      0|        fatalError("Mock connection events are not implemented")
  612|      0|    }
  613|       |    
  614|    261|    fileprivate func ensurePoweredOn() -> Bool {
  615|    261|        guard state == .poweredOn else {
  616|      6|            NSLog("[CoreBluetoothMock] API MISUSE: \(self) can only accept this command while in the powered on state")
  617|      6|            return false
  618|    255|        }
  619|    255|        return true
  620|    261|    }
  621|       |    
  622|       |}
  623|       |
  624|       |// MARK: - CBPeripheralMock implementation
  625|       |
  626|       |open class CBMPeripheralMock: CBMPeer, CBMPeripheral {
  627|       |    
  628|       |    /// The parent central manager.
  629|       |    private let manager: CBMCentralManagerMock
  630|       |    /// The dispatch queue to call delegate methods on.
  631|    273|    private var queue: DispatchQueue {
  632|    273|        return manager.queue
  633|    273|    }
  634|       |    /// The mock peripheral with user-defined implementation.
  635|       |    private let mock: CBMPeripheralSpec
  636|       |    /// Size of the outgoing buffer. Only this many packets
  637|       |    /// can be written without response in a loop, without
  638|       |    /// waiting for `canSendWriteWithoutResponse`.
  639|       |    private let bufferSize =  20
  640|       |    /// The supervision timeout is a time after which a device realizes
  641|       |    /// that a connected peer has disconnected, had there been no signal
  642|       |    /// from it.
  643|       |    private let supervisionTimeout = 4.0
  644|       |    /// The current buffer size.
  645|       |    private var availableWriteWithoutResponseBuffer: Int
  646|       |    private var _canSendWriteWithoutResponse: Bool = false
  647|       |    
  648|       |    /// A flag set to <i>true</i> when the device was scanned
  649|       |    /// at least once.
  650|       |    fileprivate var wasScanned: Bool   = false
  651|       |    /// A flag set to <i>true</i> when the device was connected
  652|       |    /// and iOS had chance to read device name.
  653|       |    fileprivate var wasConnected: Bool = false
  654|       |    
  655|       |    open var delegate: CBMPeripheralDelegate?
  656|       |    
  657|    183|    open override var identifier: UUID {
  658|    183|        return mock.identifier
  659|    183|    }
  660|    137|    open var name: String? {
  661|    137|        // If the device wasn't connected and has just been scanned first time,
  662|    137|        // return nil. When scanning continued, the Local Name from the
  663|    137|        // advertisement data is returned. When the device was connected, the
  664|    137|        // central reads the Device Name characteristic and returns cached value.
  665|    137|        return wasConnected ?
  666|    137|            mock.name :
  667|    137|            wasScanned ?
  668|    137|                mock.advertisementData?[CBMAdvertisementDataLocalNameKey] as? String :
  669|    137|                nil
  670|    137|    }
  671|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  672|      2|    open var canSendWriteWithoutResponse: Bool {
  673|      2|        return _canSendWriteWithoutResponse
  674|      2|    }
  675|       |    open private(set) var ancsAuthorized: Bool = false
  676|     42|    open private(set) var state: CBMPeripheralState = .disconnected
  677|       |    open private(set) var services: [CBMService]? = nil
  678|       |    
  679|       |    // MARK: Initializers
  680|       |    
  681|       |    fileprivate init(basedOn mock: CBMPeripheralSpec,
  682|     42|                     by manager: CBMCentralManagerMock) {
  683|     42|        self.mock = mock
  684|     42|        self.manager = manager
  685|     42|        self.availableWriteWithoutResponseBuffer = bufferSize
  686|     42|    }
  687|       |    
  688|       |    fileprivate init(copy: CBMPeripheralMock,
  689|      0|                     by manager: CBMCentralManagerMock) {
  690|      0|        self.mock = copy.mock
  691|      0|        self.manager = manager
  692|      0|        self.availableWriteWithoutResponseBuffer = bufferSize
  693|      0|    }
  694|       |    
  695|       |    // MARK: Connection
  696|       |    
  697|     35|    fileprivate func connect(completion: @escaping (Result<Void, Error>) -> ()) {
  698|     35|        // Ensure the device is disconnected.
  699|     35|        guard state == .disconnected || state == .connecting else {
  700|      0|            return
  701|     35|        }
  702|     35|        // Connection is pending.
  703|     35|        state = .connecting
  704|     35|        // Ensure the device is connectable and in range.
  705|     35|        guard let delegate = mock.connectionDelegate,
  706|     35|              let interval = mock.connectionInterval,
  707|     35|              mock.proximity != .outOfRange else {
  708|      1|            // There's no timeout on iOS. The device will connect when brought back
  709|      1|            // into range. To cancel pending connection, call disconnect().
  710|      1|            return
  711|     34|        }
  712|     34|        let result = delegate.peripheralDidReceiveConnectionRequest(mock)
  713|     34|        queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  714|     34|            if let self = self, self.state == .connecting {
  715|     34|                if case .success = result {
  716|     34|                    self.state = .connected
  717|     34|                    self._canSendWriteWithoutResponse = true
  718|     34|                    self.mock.virtualConnections += 1
  719|     34|                } else {
  720|      0|                    self.state = .disconnected
  721|     34|                }
  722|     34|                completion(result)
  723|     34|            }
  724|     34|        }
  725|     34|    }
  726|       |    
  727|     31|    fileprivate func disconnect(completion: @escaping () -> ()) {
  728|     31|        // Cancel pending connection.
  729|     31|        guard state != .connecting else {
  730|      1|            state = .disconnected
  731|      1|            queue.async {
  732|      1|                completion()
  733|      1|            }
  734|      1|            return
  735|     30|        }
  736|     30|        // Ensure the device is connectable and connected.
  737|     30|        guard let interval = mock.connectionInterval,
  738|     30|              state == .connected else {
  739|      1|            return
  740|     29|        }
  741|     29|        if #available(iOS 9.0, *), case .connected = state {
  742|     29|            state = .disconnecting
  743|     29|        }
  744|     29|        queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  745|     29|            if let self = self, CBMCentralManagerMock.managerState == .poweredOn {
  746|     29|                self.state = .disconnected
  747|     29|                self.services = nil
  748|     29|                self._canSendWriteWithoutResponse = false
  749|     29|                self.mock.virtualConnections -= 1
  750|     29|                self.mock.connectionDelegate?.peripheral(self.mock,
  751|     29|                                                         didDisconnect: nil)
  752|     29|                completion()
  753|     29|            }
  754|     29|        }
  755|     29|    }
  756|       |    
  757|       |    fileprivate func disconnected(withError error: Error,
  758|      4|                                  completion: @escaping (Error?) -> ()) {
  759|      4|        // Ensure the device is connected.
  760|      4|        guard var interval = mock.connectionInterval,
  761|      4|              state == .connected else {
  762|      0|            return
  763|      4|        }
  764|      4|        // If a device disconnected with a timeout, the central waits
  765|      4|        // for the duration of supervision timeout before accepting
  766|      4|        // disconnection.
  767|      4|        if let error = error as? CBMError, error.code == .connectionTimeout {
  768|      1|            interval = supervisionTimeout
  769|      4|        }
  770|      4|        queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  771|      4|            if let self = self, CBMCentralManagerMock.managerState == .poweredOn {
  772|      4|                self.state = .disconnected
  773|      4|                self.services = nil
  774|      4|                self._canSendWriteWithoutResponse = false
  775|      4|                // If the disconnection happen without an error, the device
  776|      4|                // must have been disconnected disconnected from central
  777|      4|                // manager.
  778|      4|                self.mock.virtualConnections = 0
  779|      4|                self.mock.connectionDelegate?.peripheral(self.mock,
  780|      4|                                                         didDisconnect: error)
  781|      4|                completion(error)
  782|      4|            }
  783|      4|        }
  784|      4|    }
  785|       |    
  786|       |    // MARK: Service modification
  787|       |    
  788|      2|    fileprivate func notifyNameChanged() {
  789|      2|        guard state == .connected,
  790|      2|              let interval = mock.connectionInterval else {
  791|      1|            return
  792|      1|        }
  793|      1|        queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  794|      1|            if let self = self, self.state == .connected {
  795|      1|                self.delegate?.peripheralDidUpdateName(self)
  796|      1|            }
  797|      1|        }
  798|      1|    }
  799|       |    
  800|      2|    fileprivate func notifyServicesChanged() {
  801|      2|        guard state == .connected,
  802|      2|              let oldServices = services,
  803|      2|              let interval = mock.connectionInterval else {
  804|      1|            return
  805|      1|        }
  806|      1|        
  807|      1|        // Keep only services that hadn't changed.
  808|      1|        services = services!
  809|      1|            .filter { service in
  810|      1|                mock.services!.contains(where: {
  811|      1|                    $0.identifier == service.identifier
  812|      1|                })
  813|      1|            }
  814|      1|        let invalidatedServices = oldServices.filter({ !services!.contains($0) })
  815|      1|        queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  816|      1|            if let self = self, self.state == .connected {
  817|      1|                self.delegate?.peripheral(self, didModifyServices: invalidatedServices)
  818|      1|            }
  819|      1|        }
  820|      1|    }
  821|       |    
  822|  4.16k|    fileprivate func notifyValueChanged(for originalCharacteristic: CBMCharacteristicMock) {
  823|  4.16k|        guard state == .connected,
  824|  4.16k|              let interval = mock.connectionInterval,
  825|  4.16k|              let service = services?.first(where: {
  826|    247|                $0.characteristics?.contains(where: {
  827|    247|                    $0.identifier == originalCharacteristic.identifier
  828|    247|                }) ?? false
  829|    190|              }),
  830|  4.16k|              let characteristic = service.characteristics?.first(where: {
  831|    198|                  $0.identifier == originalCharacteristic.identifier
  832|    198|              }),
  833|  4.16k|              characteristic.isNotifying else {
  834|  4.03k|            return
  835|  4.03k|        }
  836|    126|        characteristic.value = originalCharacteristic.value
  837|    126|        queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  838|    126|            if let self = self, self.state == .connected {
  839|    124|                self.delegate?.peripheral(self,
  840|    124|                                          didUpdateValueFor: characteristic,
  841|    124|                                          error: nil)
  842|    126|            }
  843|    126|        }
  844|    126|    }
  845|       |    
  846|     35|    fileprivate func managerPoweredOff() {
  847|     35|        state = .disconnected
  848|     35|        services = nil
  849|     35|        _canSendWriteWithoutResponse = false
  850|     35|        mock.virtualConnections = 0
  851|     35|    }
  852|       |    
  853|       |    // MARK: Service discovery
  854|       |    
  855|     21|    open func discoverServices(_ serviceUUIDs: [CBMUUID]?) {
  856|     21|        // Central manager must be in powered on state.
  857|     21|        guard manager.ensurePoweredOn() else { return }
  858|     21|        guard state == .connected,
  859|     21|              let delegate = mock.connectionDelegate,
  860|     21|              let interval = mock.connectionInterval,
  861|     21|              let allServices = mock.services else {
  862|      0|            return
  863|     21|        }
  864|     21|        
  865|     21|        switch delegate.peripheral(mock,
  866|     21|                                   didReceiveServiceDiscoveryRequest: serviceUUIDs) {
  867|     21|        case .success:
  868|     21|            services = services ?? []
  869|     21|            let initialSize = services!.count
  870|     21|            services = services! + allServices
  871|     21|                // Filter all device services that match given list (if set).
  872|     21|                .filter { serviceUUIDs?.contains($0.uuid) ?? true }
  873|     21|                // Filter those of them, that are not already in discovered services.
  874|     21|                .filter { s in !services!
  875|     20|                    .contains(where: { ds in s.identifier == ds.identifier })
  876|     20|                }
  877|     21|                // Copy the service info, without included services or characteristics.
  878|     21|                .map { CBMService(shallowCopy: $0, for: self) }
  879|     21|            let newServicesCount = services!.count - initialSize
  880|     21|            // Service discovery may takes the more time, the more services
  881|     21|            // are discovered.
  882|     21|            queue.asyncAfter(deadline: .now() + interval * Double(newServicesCount)) { [weak self] in
  883|     21|                if let self = self, self.state == .connected {
  884|     20|                    self.delegate?.peripheral(self, didDiscoverServices: nil)
  885|     21|                }
  886|     21|            }
  887|     21|        case .failure(let error):
  888|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  889|      0|                if let self = self, self.state == .connected {
  890|      0|                    self.delegate?.peripheral(self, didDiscoverServices: error)
  891|      0|                }
  892|      0|            }
  893|     21|        }
  894|     21|    }
  895|       |    
  896|       |    open func discoverIncludedServices(_ includedServiceUUIDs: [CBMUUID]?,
  897|      0|                                         for service: CBMService) {
  898|      0|        // Central manager must be in powered on state.
  899|      0|        guard manager.ensurePoweredOn() else { return }
  900|      0|        guard state == .connected,
  901|      0|              let delegate = mock.connectionDelegate,
  902|      0|              let interval = mock.connectionInterval,
  903|      0|              let allServices = mock.services else {
  904|      0|            return
  905|      0|        }
  906|      0|        guard let services = services, services.contains(service),
  907|      0|              let originalService = allServices.first(where: {
  908|      0|                  $0.identifier == service.identifier
  909|      0|              }) else {
  910|      0|            return
  911|      0|        }
  912|      0|        guard let originalIncludedServices = originalService.includedServices else {
  913|      0|            return
  914|      0|        }
  915|      0|        
  916|      0|        switch delegate.peripheral(mock,
  917|      0|                                   didReceiveIncludedServiceDiscoveryRequest: includedServiceUUIDs,
  918|      0|                                   for: service as! CBMServiceMock) {
  919|      0|        case .success:
  920|      0|            service._includedServices = service._includedServices ?? []
  921|      0|            let initialSize = service._includedServices!.count
  922|      0|            service._includedServices = service._includedServices! +
  923|      0|                originalIncludedServices
  924|      0|                    // Filter all included service that match given list (if set).
  925|      0|                    .filter { includedServiceUUIDs?.contains($0.uuid) ?? true }
  926|      0|                    // Filter those of them, that are not already in discovered services.
  927|      0|                    .filter { s in !service._includedServices!
  928|      0|                        .contains(where: { ds in s.identifier == ds.identifier })
  929|      0|                    }
  930|      0|                    // Copy the service info, without included characteristics.
  931|      0|                    .map { CBMService(shallowCopy: $0, for: self) }
  932|      0|            let newServicesCount = service._includedServices!.count - initialSize
  933|      0|            // Service discovery may takes the more time, the more services
  934|      0|            // are discovered.
  935|      0|            queue.asyncAfter(deadline: .now() + interval * Double(newServicesCount)) { [weak self] in
  936|      0|                if let self = self, self.state == .connected {
  937|      0|                    self.delegate?.peripheral(self,
  938|      0|                                              didDiscoverIncludedServicesFor: service,
  939|      0|                                              error: nil)
  940|      0|                }
  941|      0|            }
  942|      0|        case .failure(let error):
  943|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
  944|      0|                if let self = self, self.state == .connected {
  945|      0|                    self.delegate?.peripheral(self,
  946|      0|                                              didDiscoverIncludedServicesFor: service,
  947|      0|                                              error: error)
  948|      0|                }
  949|      0|            }
  950|      0|        }
  951|      0|        
  952|      0|    }
  953|       |    
  954|       |    open func discoverCharacteristics(_ characteristicUUIDs: [CBMUUID]?,
  955|     22|                                        for service: CBMService) {
  956|     22|        // Central manager must be in powered on state.
  957|     22|        guard manager.ensurePoweredOn() else { return }
  958|     22|        guard state == .connected,
  959|     22|              let delegate = mock.connectionDelegate,
  960|     22|              let interval = mock.connectionInterval,
  961|     22|              let allServices = mock.services else {
  962|      0|            return
  963|     22|        }
  964|     22|        guard let services = services, services.contains(service),
  965|     22|              let originalService = allServices.first(where: {
  966|     22|                  $0.identifier == service.identifier
  967|     22|              }) else {
  968|      0|            return
  969|     22|        }
  970|     22|        guard let originalCharacteristics = originalService.characteristics else {
  971|      0|            return
  972|     22|        }
  973|     22|        
  974|     22|        switch delegate.peripheral(mock,
  975|     22|                                   didReceiveCharacteristicsDiscoveryRequest: characteristicUUIDs,
  976|     22|                                   for: service) {
  977|     22|        case .success:
  978|     22|            service._characteristics = service._characteristics ?? []
  979|     22|            let initialSize = service._characteristics!.count
  980|     22|            service._characteristics = service._characteristics! +
  981|     22|                originalCharacteristics
  982|     22|                    // Filter all service characteristics that match given list (if set).
  983|     44|                    .filter { characteristicUUIDs?.contains($0.uuid) ?? true }
  984|     22|                    // Filter those of them, that are not already in discovered characteristics.
  985|     22|                    .filter { c in !service._characteristics!
  986|     20|                        .contains(where: { dc in c.identifier == dc.identifier })
  987|     20|                    }
  988|     22|                    // Copy the characteristic info, without included descriptors or value.
  989|     22|                    .map { CBMCharacteristic(shallowCopy: $0, in: service) }
  990|     22|            let newCharacteristicsCount = service._characteristics!.count - initialSize
  991|     22|            // Characteristics discovery may takes the more time, the more characteristics
  992|     22|            // are discovered.
  993|     22|            queue.asyncAfter(deadline: .now() + interval * Double(newCharacteristicsCount)) { [weak self] in
  994|     22|                if let self = self, self.state == .connected {
  995|     22|                    self.delegate?.peripheral(self,
  996|     22|                                              didDiscoverCharacteristicsFor: service,
  997|     22|                                              error: nil)
  998|     22|                }
  999|     22|            }
 1000|     22|        case .failure(let error):
 1001|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1002|      0|                if let self = self, self.state == .connected {
 1003|      0|                    self.delegate?.peripheral(self,
 1004|      0|                                              didDiscoverCharacteristicsFor: service,
 1005|      0|                                              error: error)
 1006|      0|                }
 1007|      0|            }
 1008|     22|        }
 1009|     22|    }
 1010|       |    
 1011|      0|    open func discoverDescriptors(for characteristic: CBMCharacteristic) {
 1012|      0|        // Central manager must be in powered on state.
 1013|      0|        guard manager.ensurePoweredOn() else { return }
 1014|      0|        guard state == .connected,
 1015|      0|              let delegate = mock.connectionDelegate,
 1016|      0|              let interval = mock.connectionInterval,
 1017|      0|              let allServices = mock.services else {
 1018|      0|            return
 1019|      0|        }
 1020|      0|        guard let services = services, services.contains(characteristic.service),
 1021|      0|              let originalService = allServices.first(where: {
 1022|      0|                  $0.identifier == characteristic.service.identifier
 1023|      0|              }),
 1024|      0|              let originalCharacteristic = originalService.characteristics?.first(where: {
 1025|      0|                  $0.identifier == characteristic.identifier
 1026|      0|              }) else {
 1027|      0|            return
 1028|      0|        }
 1029|      0|        guard let originalDescriptors = originalCharacteristic.descriptors else {
 1030|      0|            return
 1031|      0|        }
 1032|      0|        
 1033|      0|        switch delegate.peripheral(mock,
 1034|      0|                                   didReceiveDescriptorsDiscoveryRequestFor: characteristic) {
 1035|      0|        case .success:
 1036|      0|            characteristic._descriptors = characteristic._descriptors ?? []
 1037|      0|            let initialSize = characteristic._descriptors!.count
 1038|      0|            characteristic._descriptors = characteristic._descriptors! +
 1039|      0|                originalDescriptors
 1040|      0|                    // Filter those of them, that are not already in discovered descriptors.
 1041|      0|                    .filter { d in !characteristic._descriptors!
 1042|      0|                        .contains(where: { dd in d.identifier == dd.identifier })
 1043|      0|                    }
 1044|      0|                    // Copy the descriptors info, without the value.
 1045|      0|                    .map { CBMDescriptor(shallowCopy: $0, in: characteristic) }
 1046|      0|            let newDescriptorsCount = characteristic._descriptors!.count - initialSize
 1047|      0|            // Descriptors discovery may takes the more time, the more descriptors
 1048|      0|            // are discovered.
 1049|      0|            queue.asyncAfter(deadline: .now() + interval * Double(newDescriptorsCount)) { [weak self] in
 1050|      0|                if let self = self, self.state == .connected {
 1051|      0|                    self.delegate?.peripheral(self,
 1052|      0|                                              didDiscoverDescriptorsFor: characteristic,
 1053|      0|                                              error: nil)
 1054|      0|                }
 1055|      0|            }
 1056|      0|        case .failure(let error):
 1057|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1058|      0|                if let self = self, self.state == .connected {
 1059|      0|                    self.delegate?.peripheral(self,
 1060|      0|                                              didDiscoverDescriptorsFor: characteristic,
 1061|      0|                                              error: error)
 1062|      0|                }
 1063|      0|            }
 1064|      0|        }
 1065|      0|    }
 1066|       |    
 1067|       |    // MARK: Read requests
 1068|       |    
 1069|      8|    open func readValue(for characteristic: CBMCharacteristic) {
 1070|      8|        // Central manager must be in powered on state.
 1071|      8|        guard manager.ensurePoweredOn() else { return }
 1072|      8|        guard state == .connected,
 1073|      8|              let delegate = mock.connectionDelegate,
 1074|      8|              let interval = mock.connectionInterval else {
 1075|      0|            return
 1076|      8|        }
 1077|      8|        guard let services = services,
 1078|      8|              services.contains(characteristic.service) else {
 1079|      0|            return
 1080|      8|        }
 1081|      8|        switch delegate.peripheral(mock,
 1082|      8|                                   didReceiveReadRequestFor: characteristic) {
 1083|      8|        case .success(let data):
 1084|      8|            characteristic.value = data
 1085|      8|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1086|      8|                if let self = self, self.state == .connected {
 1087|      8|                    self.delegate?.peripheral(self,
 1088|      8|                                              didUpdateValueFor: characteristic,
 1089|      8|                                              error: nil)
 1090|      8|                }
 1091|      8|            }
 1092|      8|        case .failure(let error):
 1093|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1094|      0|                if let self = self, self.state == .connected {
 1095|      0|                    self.delegate?.peripheral(self,
 1096|      0|                                              didUpdateValueFor: characteristic,
 1097|      0|                                              error: error)
 1098|      0|                }
 1099|      0|            }
 1100|      8|        }
 1101|      8|    }
 1102|       |    
 1103|      0|    open func readValue(for descriptor: CBMDescriptor) {
 1104|      0|        // Central manager must be in powered on state.
 1105|      0|        guard manager.ensurePoweredOn() else { return }
 1106|      0|        guard state == .connected,
 1107|      0|              let delegate = mock.connectionDelegate,
 1108|      0|              let interval = mock.connectionInterval else {
 1109|      0|            return
 1110|      0|        }
 1111|      0|        guard let services = services,
 1112|      0|              services.contains(descriptor.characteristic.service) else {
 1113|      0|            return
 1114|      0|        }
 1115|      0|        switch delegate.peripheral(mock,
 1116|      0|                                   didReceiveReadRequestFor: descriptor) {
 1117|      0|        case .success(let data):
 1118|      0|            descriptor.value = data
 1119|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1120|      0|                if let self = self, self.state == .connected {
 1121|      0|                    self.delegate?.peripheral(self,
 1122|      0|                                              didUpdateValueFor: descriptor,
 1123|      0|                                              error: nil)
 1124|      0|                }
 1125|      0|            }
 1126|      0|        case .failure(let error):
 1127|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1128|      0|                if let self = self, self.state == .connected {
 1129|      0|                    self.delegate?.peripheral(self,
 1130|      0|                                              didUpdateValueFor: descriptor,
 1131|      0|                                              error: error)
 1132|      0|                }
 1133|      0|            }
 1134|      0|        }
 1135|      0|    }
 1136|       |    
 1137|       |    // MARK: Write requests
 1138|       |    
 1139|       |    open func writeValue(_ data: Data,
 1140|       |                           for characteristic: CBMCharacteristic,
 1141|      6|                           type: CBMCharacteristicWriteType) {
 1142|      6|        // Central manager must be in powered on state.
 1143|      6|        guard manager.ensurePoweredOn() else { return }
 1144|      6|        guard state == .connected,
 1145|      6|              let delegate = mock.connectionDelegate,
 1146|      6|              let interval = mock.connectionInterval,
 1147|      6|              let mtu = mock.mtu else {
 1148|      0|            return
 1149|      6|        }
 1150|      6|        guard let services = services,
 1151|      6|              services.contains(characteristic.service) else {
 1152|      0|            return
 1153|      6|        }
 1154|      6|        
 1155|      6|        if type == .withResponse {
 1156|      4|            switch delegate.peripheral(mock,
 1157|      4|                                       didReceiveWriteRequestFor: characteristic,
 1158|      4|                                       data: data) {
 1159|      4|            case .success:
 1160|      4|                let packetsCount = max(1, (data.count + mtu - 2) / (mtu - 3))
 1161|      4|                queue.asyncAfter(deadline: .now() + interval * Double(packetsCount)) { [weak self] in
 1162|      4|                    if let self = self, self.state == .connected {
 1163|      4|                        self.delegate?.peripheral(self,
 1164|      4|                                                  didWriteValueFor: characteristic,
 1165|      4|                                                  error: nil)
 1166|      4|                    }
 1167|      4|                }
 1168|      4|            case .failure(let error):
 1169|      0|                queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1170|      0|                    if let self = self, self.state == .connected {
 1171|      0|                        self.delegate?.peripheral(self,
 1172|      0|                                                  didWriteValueFor: characteristic,
 1173|      0|                                                  error: error)
 1174|      0|                    }
 1175|      0|                }
 1176|      4|            }
 1177|      6|        } else {
 1178|      2|            let decreaseBuffer = { [weak self] in
 1179|      2|                guard let strongSelf = self,
 1180|      2|                    strongSelf.availableWriteWithoutResponseBuffer > 0 else {
 1181|      0|                    return
 1182|      2|                }
 1183|      2|                strongSelf.availableWriteWithoutResponseBuffer -= 1
 1184|      2|                strongSelf._canSendWriteWithoutResponse = false
 1185|      2|            }
 1186|      2|            if DispatchQueue.main.label == queue.label {
 1187|      2|                decreaseBuffer()
 1188|      2|            } else {
 1189|      0|                queue.sync {
 1190|      0|                    decreaseBuffer()
 1191|      0|                }
 1192|      2|            }
 1193|      2|            
 1194|      2|            delegate.peripheral(mock,
 1195|      2|                                didReceiveWriteCommandFor: characteristic,
 1196|      2|                                data: data.subdata(in: 0..<mtu - 3))
 1197|      2|            queue.async { [weak self] in
 1198|      2|                if let self = self, self.state == .connected {
 1199|      0|                    let increaseBuffer = {
 1200|      0|                        self.availableWriteWithoutResponseBuffer += 1
 1201|      0|                        self._canSendWriteWithoutResponse = true
 1202|      0|                    }
 1203|      0|                    if DispatchQueue.main.label == self.queue.label {
 1204|      0|                        increaseBuffer()
 1205|      0|                    } else {
 1206|      0|                        self.queue.sync {
 1207|      0|                            increaseBuffer()
 1208|      0|                        }
 1209|      0|                    }
 1210|      0|                    if #available(iOS 11.0, tvOS 11.0, watchOS 4.0, *) {
 1211|      0|                        self.delegate?.peripheralIsReady(toSendWriteWithoutResponse: self)
 1212|      0|                    }
 1213|      2|                }
 1214|      2|            }
 1215|      6|        }
 1216|      6|    }
 1217|       |    
 1218|      0|    open func writeValue(_ data: Data, for descriptor: CBMDescriptor) {
 1219|      0|        // Central manager must be in powered on state.
 1220|      0|        guard manager.ensurePoweredOn() else { return }
 1221|      0|        guard state == .connected,
 1222|      0|              let delegate = mock.connectionDelegate,
 1223|      0|              let interval = mock.connectionInterval else {
 1224|      0|            return
 1225|      0|        }
 1226|      0|        guard let services = services,
 1227|      0|              services.contains(descriptor.characteristic.service) else {
 1228|      0|            return
 1229|      0|        }
 1230|      0|        
 1231|      0|        switch delegate.peripheral(mock,
 1232|      0|                                   didReceiveWriteRequestFor: descriptor,
 1233|      0|                                   data: data) {
 1234|      0|        case .success:
 1235|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1236|      0|                if let self = self, self.state == .connected {
 1237|      0|                    self.delegate?.peripheral(self,
 1238|      0|                                              didWriteValueFor: descriptor,
 1239|      0|                                              error: nil)
 1240|      0|                }
 1241|      0|            }
 1242|      0|        case .failure(let error):
 1243|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1244|      0|                if let self = self, self.state == .connected {
 1245|      0|                    self.delegate?.peripheral(self,
 1246|      0|                                              didWriteValueFor: descriptor,
 1247|      0|                                              error: error)
 1248|      0|                }
 1249|      0|            }
 1250|      0|        }
 1251|      0|    }
 1252|       |    
 1253|       |    @available(iOS 9.0, *)
 1254|      0|    open func maximumWriteValueLength(for type: CBMCharacteristicWriteType) -> Int {
 1255|      0|        // Central manager must be in powered on state.
 1256|      0|        guard manager.ensurePoweredOn() else { return 0 }
 1257|      0|        guard state == .connected, let mtu = mock.mtu else {
 1258|      0|            return 0
 1259|      0|        }
 1260|      0|        return type == .withResponse ? 512 : mtu - 3
 1261|      0|    }
 1262|       |    
 1263|       |    // MARK: Enabling notifications and indications
 1264|       |    
 1265|       |    open func setNotifyValue(_ enabled: Bool,
 1266|     16|                               for characteristic: CBMCharacteristic) {
 1267|     16|        // Central manager must be in powered on state.
 1268|     16|        guard manager.ensurePoweredOn() else { return }
 1269|     16|        guard state == .connected,
 1270|     16|              let delegate = mock.connectionDelegate,
 1271|     16|              let interval = mock.connectionInterval else {
 1272|      0|            return
 1273|     16|        }
 1274|     16|        guard let services = services,
 1275|     16|              services.contains(characteristic.service) else {
 1276|      0|            return
 1277|     16|        }
 1278|     16|        guard enabled != characteristic.isNotifying else {
 1279|      0|            return
 1280|     16|        }
 1281|     16|        
 1282|     16|        switch delegate.peripheral(mock,
 1283|     16|                                   didReceiveSetNotifyRequest: enabled,
 1284|     16|                                   for: characteristic) {
 1285|     16|        case .success:
 1286|     16|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1287|     16|                if let self = self, self.state == .connected {
 1288|     16|                    characteristic.isNotifying = enabled
 1289|     16|                    self.delegate?.peripheral(self,
 1290|     16|                                              didUpdateNotificationStateFor: characteristic,
 1291|     16|                                              error: nil)
 1292|     16|                }
 1293|     16|            }
 1294|     16|        case .failure(let error):
 1295|      0|            queue.asyncAfter(deadline: .now() + interval) { [weak self] in
 1296|      0|                if let self = self, self.state == .connected {
 1297|      0|                    self.delegate?.peripheral(self,
 1298|      0|                                              didUpdateNotificationStateFor: characteristic,
 1299|      0|                                              error: error)
 1300|      0|                }
 1301|      0|            }
 1302|     16|        }        
 1303|     16|    }
 1304|       |    
 1305|       |    // MARK: Other
 1306|       |    
 1307|      2|    open func readRSSI() {
 1308|      2|        // Central manager must be in powered on state.
 1309|      2|        guard manager.ensurePoweredOn() else { return }
 1310|      2|        queue.async { [weak self] in
 1311|      2|            if let self = self, self.state == .connected {
 1312|      2|                let rssi = self.mock.proximity.RSSI
 1313|      2|                let delta = CBMCentralManagerMock.rssiDeviation
 1314|      2|                let deviation = Int.random(in: -delta...delta)
 1315|      2|                self.delegate?.peripheral(self, didReadRSSI: (rssi + deviation) as NSNumber,
 1316|      2|                                          error: nil)
 1317|      2|            }
 1318|      2|        }
 1319|      2|    }
 1320|       |    
 1321|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
 1322|      0|    open func openL2CAPChannel(_ PSM: CBML2CAPPSM) {
 1323|      0|        fatalError("L2CAP mock is not implemented")
 1324|      0|    }
 1325|       |    
 1326|      0|    open override var hash: Int {
 1327|      0|        return mock.identifier.hashValue
 1328|      0|    }
 1329|       |}
 1330|       |
 1331|       |// MARK: - Helpers
 1332|       |
 1333|       |private class WeakRef<T: AnyObject> {
 1334|       |    fileprivate private(set) weak var ref: T?
 1335|       |    
 1336|     42|    fileprivate init(_ value: T) {
 1337|     42|        self.ref = value
 1338|     42|    }
 1339|       |}
 1340|       |
 1341|       |private extension Dictionary where Key == UUID, Value == CBMPeripheralMock {
 1342|       |    
 1343|     35|    subscript(identifiers: [UUID]) -> [CBMPeripheralMock] {
 1344|     35|        return identifiers.compactMap { self[$0] }
 1345|     35|    }
 1346|       |    
 1347|      0|    subscript(serviceUUIDs: [CBMUUID]) -> [CBMPeripheralMock] {
 1348|      0|        return filter { (_, peripheral) in
 1349|      0|            peripheral.services?
 1350|      0|                .contains(where: { service in
 1351|      0|                    serviceUUIDs.contains(service.uuid)
 1352|      0|                })
 1353|      0|            ?? false
 1354|      0|        }.map { $0.value }
 1355|      0|    }
 1356|       |    
 1357|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMCentralManagerNative.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |public class CBMCentralManagerNative: NSObject, CBMCentralManager {
   34|       |    public weak var delegate: CBMCentralManagerDelegate?
   35|       |    
   36|       |    private var manager: CBCentralManager!
   37|       |    private var wrapper: CBCentralManagerDelegate!
   38|      0|    private var peripherals: [UUID : CBMPeripheralNative] = [:]
   39|       |    
   40|       |    private class CBMCentralManagerDelegateWrapper: NSObject, CBCentralManagerDelegate {
   41|       |        fileprivate weak var manager: CBMCentralManagerNative! // weak to avoid cyclic reference (#9)
   42|       |        
   43|      0|        init(_ manager: CBMCentralManagerNative) {
   44|      0|            self.manager = manager
   45|      0|        }
   46|       |        
   47|      0|        func centralManagerDidUpdateState(_ central: CBCentralManager) {
   48|      0|            manager.delegate?.centralManagerDidUpdateState(manager)
   49|      0|        }
   50|       |        
   51|       |        // This methods is moved to a separate class below. Otherwise a warning
   52|       |        // is generated when setting delegate to the CBCentralManager when
   53|       |        // restoration was not enabled.
   54|       |        //
   55|       |        // func centralManager(_ central: CBCentralManager,
   56|       |        //                     willRestoreState dict: [String : Any]) {
   57|       |        //     manager.delegate?.centralManager(manager, willRestoreState: dict)
   58|       |        // }
   59|       |        
   60|       |        func centralManager(_ central: CBCentralManager,
   61|       |                            didDiscover peripheral: CBPeripheral,
   62|       |                            advertisementData: [String : Any],
   63|      0|                            rssi RSSI: NSNumber) {
   64|      0|            manager.delegate?.centralManager(manager,
   65|      0|                                             didDiscover: getPeripheral(peripheral),
   66|      0|                                             advertisementData: advertisementData,
   67|      0|                                             rssi: RSSI)
   68|      0|        }
   69|       |        
   70|       |        func centralManager(_ central: CBCentralManager,
   71|      0|                            didConnect peripheral: CBPeripheral) {
   72|      0|            manager.delegate?.centralManager(manager,
   73|      0|                                             didConnect: getPeripheral(peripheral))
   74|      0|        }
   75|       |        
   76|       |        func centralManager(_ central: CBCentralManager,
   77|       |                            didFailToConnect peripheral: CBPeripheral,
   78|      0|                            error: Error?) {
   79|      0|            manager.delegate?.centralManager(manager,
   80|      0|                                             didFailToConnect: getPeripheral(peripheral),
   81|      0|                                             error: error)
   82|      0|        }
   83|       |        
   84|       |        func centralManager(_ central: CBCentralManager,
   85|       |                            didDisconnectPeripheral peripheral: CBPeripheral,
   86|      0|                            error: Error?) {
   87|      0|            manager.delegate?.centralManager(manager,
   88|      0|                                             didDisconnectPeripheral: getPeripheral(peripheral),
   89|      0|                                             error: error)
   90|      0|        }
   91|       |        
   92|       |        #if !os(macOS)
   93|       |        @available(iOS 13.0, *)
   94|       |        func centralManager(_ central: CBCentralManager,
   95|      0|                            didUpdateANCSAuthorizationFor peripheral: CBPeripheral) {
   96|      0|            manager.delegate?.centralManager(manager,
   97|      0|                                             didUpdateANCSAuthorizationFor: getPeripheral(peripheral))
   98|      0|        }
   99|       |        #endif
  100|       |        
  101|       |        #if !os(macOS)
  102|       |        @available(iOS 13.0, *)
  103|       |        func centralManager(_ central: CBCentralManager,
  104|       |                            connectionEventDidOccur event: CBConnectionEvent,
  105|      0|                            for peripheral: CBPeripheral) {
  106|      0|            manager.delegate?.centralManager(manager,
  107|      0|                                             connectionEventDidOccur: event,
  108|      0|                                             for: getPeripheral(peripheral))
  109|      0|        }
  110|       |        #endif
  111|       |        
  112|      0|        private func getPeripheral(_ peripheral: CBPeripheral) -> CBMPeripheralNative {
  113|      0|            return manager.peripherals[peripheral.identifier] ?? newPeripheral(peripheral)
  114|      0|        }
  115|       |        
  116|      0|        private func newPeripheral(_ peripheral: CBPeripheral) -> CBMPeripheralNative {
  117|      0|            let p = CBMPeripheralNative(peripheral)
  118|      0|            manager.peripherals[peripheral.identifier] = p
  119|      0|            return p
  120|      0|        }
  121|       |    }
  122|       |    
  123|       |    private class CBMCentralManagerDelegateWrapperWithRestoration: CBMCentralManagerDelegateWrapper {
  124|       |        
  125|      0|        override init(_ manager: CBMCentralManagerNative) {
  126|      0|            super.init(manager)
  127|      0|        }
  128|       |        
  129|       |        func centralManager(_ central: CBCentralManager,
  130|      0|                            willRestoreState dict: [String : Any]) {
  131|      0|            manager.delegate?.centralManager(manager, willRestoreState: dict)
  132|      0|        }
  133|       |    }
  134|       |    
  135|      0|    public var state: CBMManagerState {
  136|      0|        return CBMManagerState(rawValue: manager.state.rawValue) ?? .unknown
  137|      0|    }
  138|       |    
  139|       |    @available(iOS 9.0, *)
  140|      0|    public var isScanning: Bool {
  141|      0|        return manager.isScanning
  142|      0|    }
  143|       |    
  144|       |    #if !os(macOS)
  145|       |    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  146|      0|    public static func supports(_ features: CBMCentralManager.Feature) -> Bool {
  147|      0|        return CBCentralManager.supports(features)
  148|      0|    }
  149|       |    #endif
  150|       |    
  151|      0|    public override init() {
  152|      0|        super.init()
  153|      0|        self.wrapper = CBMCentralManagerDelegateWrapper(self)
  154|      0|        self.manager = CBCentralManager()
  155|      0|        self.manager.delegate = wrapper
  156|      0|    }
  157|       |    
  158|      0|    public init(delegate: CBMCentralManagerDelegate?, queue: DispatchQueue?) {
  159|      0|        super.init()
  160|      0|        self.wrapper = CBMCentralManagerDelegateWrapper(self)
  161|      0|        self.manager = CBCentralManager(delegate: wrapper, queue: queue)
  162|      0|        self.delegate = delegate
  163|      0|    }
  164|       |    
  165|       |    @available(iOS 7.0, *)
  166|       |    public init(delegate: CBMCentralManagerDelegate?, queue: DispatchQueue?,
  167|      0|                options: [String : Any]?) {
  168|      0|        super.init()
  169|      0|        let restoration = options?[CBMCentralManagerOptionRestoreIdentifierKey] != nil
  170|      0|        self.wrapper = restoration ?
  171|      0|            CBMCentralManagerDelegateWrapperWithRestoration(self) :
  172|      0|            CBMCentralManagerDelegateWrapper(self)
  173|      0|        self.manager = CBCentralManager(delegate: wrapper, queue: queue, options: options)
  174|      0|        self.delegate = delegate
  175|      0|    }
  176|       |    
  177|       |    public func scanForPeripherals(withServices serviceUUIDs: [CBMUUID]?,
  178|      0|                                   options: [String : Any]?) {
  179|      0|        manager.scanForPeripherals(withServices: serviceUUIDs, options: options)
  180|      0|    }
  181|       |    
  182|      0|    public func stopScan() {
  183|      0|        manager.stopScan()
  184|      0|    }
  185|       |    
  186|      0|    public func connect(_ peripheral: CBMPeripheral, options: [String : Any]?) {
  187|      0|        if let peripheral = peripherals[peripheral.identifier] {
  188|      0|            manager.connect(peripheral.peripheral, options: options)
  189|      0|        }
  190|      0|    }
  191|       |    
  192|      0|    public func cancelPeripheralConnection(_ peripheral: CBMPeripheral) {
  193|      0|        if let peripheral = peripherals[peripheral.identifier] {
  194|      0|            manager.cancelPeripheralConnection(peripheral.peripheral)
  195|      0|        }
  196|      0|    }
  197|       |    
  198|       |    @available(iOS 7.0, *)
  199|      0|    public func retrievePeripherals(withIdentifiers identifiers: [UUID]) -> [CBMPeripheral] {
  200|      0|        let retrievedPeripherals = manager.retrievePeripherals(withIdentifiers: identifiers)
  201|      0|        retrievedPeripherals
  202|      0|            .filter { peripherals[$0.identifier] == nil }
  203|      0|            .forEach { peripherals[$0.identifier] = CBMPeripheralNative($0) }
  204|      0|        return peripherals
  205|      0|            .filter { identifiers.contains($0.key) }
  206|      0|            .map { $0.value }
  207|      0|    }
  208|       |    
  209|       |    @available(iOS 7.0, *)
  210|      0|    public func retrieveConnectedPeripherals(withServices serviceUUIDs: [CBMUUID]) -> [CBMPeripheral] {
  211|      0|        let retrievedPeripherals = manager.retrieveConnectedPeripherals(withServices: serviceUUIDs)
  212|      0|        retrievedPeripherals
  213|      0|            .filter { peripherals[$0.identifier] == nil }
  214|      0|            .forEach { peripherals[$0.identifier] = CBMPeripheralNative($0) }
  215|      0|        return peripherals
  216|      0|            .filter { entry in retrievedPeripherals.contains(where: { $0.identifier == entry.key }) }
  217|      0|            .map { $0.value }
  218|      0|    }
  219|       |    
  220|       |    #if !os(macOS)
  221|       |    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  222|      0|    public func registerForConnectionEvents(options: [CBMConnectionEventMatchingOption : Any]? = nil) {
  223|      0|        manager.registerForConnectionEvents(options: options)
  224|      0|    }
  225|       |    #endif
  226|       |}
  227|       |
  228|       |public class CBMPeripheralNative: CBMPeer, CBMPeripheral {
  229|       |    
  230|       |    private class CBPeripheralDelegateWrapper: NSObject, CBPeripheralDelegate {
  231|       |        private var impl: CBMPeripheralNative
  232|       |        
  233|      0|        init(_ peripheral: CBMPeripheralNative) {
  234|      0|            self.impl = peripheral
  235|      0|        }
  236|       |        
  237|      0|        func peripheralDidUpdateName(_ peripheral: CBPeripheral) {
  238|      0|            impl.delegate?.peripheralDidUpdateName(impl)
  239|      0|        }
  240|       |        
  241|       |        func peripheral(_ peripheral: CBPeripheral,
  242|      0|                        didDiscoverServices error: Error?) {
  243|      0|            smartCopy(peripheral.services)
  244|      0|            impl.delegate?.peripheral(impl, didDiscoverServices: error)
  245|      0|        }
  246|       |        
  247|       |        func peripheral(_ peripheral: CBPeripheral,
  248|       |                        didDiscoverIncludedServicesFor service: CBService,
  249|      0|                        error: Error?) {
  250|      0|            smartCopy(peripheral.services)
  251|      0|            usingMock(of: service) { peripheral, delegate, service in
  252|      0|                delegate.peripheral(peripheral,
  253|      0|                                    didDiscoverIncludedServicesFor: service,
  254|      0|                                    error: error)
  255|      0|            }
  256|      0|        }
  257|       |        
  258|       |        func peripheral(_ peripheral: CBPeripheral,
  259|       |                        didDiscoverCharacteristicsFor service: CBService,
  260|      0|                        error: Error?) {
  261|      0|            smartCopy(peripheral.services)
  262|      0|            usingMock(of: service) { peripheral, delegate, service in
  263|      0|                delegate.peripheral(peripheral,
  264|      0|                                    didDiscoverCharacteristicsFor: service,
  265|      0|                                    error: error)
  266|      0|            }
  267|      0|        }
  268|       |        
  269|       |        func peripheral(_ peripheral: CBPeripheral,
  270|       |                        didDiscoverDescriptorsFor characteristic: CBCharacteristic,
  271|      0|                        error: Error?) {
  272|      0|            smartCopy(peripheral.services)
  273|      0|            usingMock(of: characteristic) { peripheral, delegate, characteristic in
  274|      0|                delegate.peripheral(peripheral,
  275|      0|                                    didDiscoverDescriptorsFor: characteristic,
  276|      0|                                    error: error)
  277|      0|            }
  278|      0|        }
  279|       |
  280|       |        @available(iOS 7.0, *)
  281|       |        func peripheral(_ peripheral: CBPeripheral,
  282|      0|                        didModifyServices invalidatedServices: [CBService]) {
  283|      0|            var invalidatedServiceMocks: [CBMService] = []
  284|      0|            invalidatedServices.forEach { service in
  285|      0|                if let services = impl.mockServices,
  286|      0|                   let index = services
  287|      0|                    .firstIndex(where: { $0.service == service}) {
  288|      0|                    invalidatedServiceMocks.append(services[index])
  289|      0|                    impl.mockServices?.remove(at: index)
  290|      0|                }
  291|      0|            }
  292|      0|            impl.delegate?.peripheral(impl, didModifyServices: invalidatedServiceMocks)
  293|      0|        }
  294|       |        
  295|       |        func peripheral(_ peripheral: CBPeripheral,
  296|       |                        didUpdateNotificationStateFor characteristic: CBCharacteristic,
  297|      0|                        error: Error?) {
  298|      0|            usingMock(of: characteristic) { peripheral, delegate, mock in
  299|      0|                mock.isNotifying = characteristic.isNotifying
  300|      0|                delegate.peripheral(peripheral,
  301|      0|                                    didUpdateNotificationStateFor: mock,
  302|      0|                                    error: error)
  303|      0|            }
  304|      0|        }
  305|       |        
  306|       |        func peripheral(_ peripheral: CBPeripheral,
  307|       |                        didWriteValueFor characteristic: CBCharacteristic,
  308|      0|                        error: Error?) {
  309|      0|            usingMock(of: characteristic) { peripheral, delegate, characteristic in
  310|      0|                delegate.peripheral(peripheral,
  311|      0|                                    didWriteValueFor: characteristic,
  312|      0|                                    error: error)
  313|      0|            }
  314|      0|        }
  315|       |        
  316|       |        func peripheral(_ peripheral: CBPeripheral,
  317|       |                        didWriteValueFor descriptor: CBDescriptor,
  318|      0|                        error: Error?) {
  319|      0|            usingMock(of: descriptor) { peripheral, delegate, descriptor in
  320|      0|                delegate.peripheral(peripheral,
  321|      0|                                    didWriteValueFor: descriptor,
  322|      0|                                    error: error)
  323|      0|            }
  324|      0|        }
  325|       |        
  326|       |        func peripheral(_ peripheral: CBPeripheral,
  327|       |                        didUpdateValueFor characteristic: CBCharacteristic,
  328|      0|                        error: Error?) {
  329|      0|            usingMock(of: characteristic) { peripheral, delegate, mockCharacteristic in
  330|      0|                mockCharacteristic.value = characteristic.value
  331|      0|                delegate.peripheral(peripheral,
  332|      0|                                    didUpdateValueFor: mockCharacteristic,
  333|      0|                                    error: error)
  334|      0|            }
  335|      0|        }
  336|       |        
  337|       |        func peripheral(_ peripheral: CBPeripheral,
  338|       |                        didUpdateValueFor descriptor: CBDescriptor,
  339|      0|                        error: Error?) {
  340|      0|            usingMock(of: descriptor) { peripheral, delegate, mockDescriptor in
  341|      0|                mockDescriptor.value = descriptor.value
  342|      0|                delegate.peripheral(peripheral,
  343|      0|                                    didUpdateValueFor: mockDescriptor,
  344|      0|                                    error: error)
  345|      0|            }
  346|      0|        }
  347|       |        
  348|       |        func peripheral(_ peripheral: CBPeripheral,
  349|       |                        didReadRSSI RSSI: NSNumber,
  350|      0|                        error: Error?) {
  351|      0|            impl.delegate?.peripheral(impl, didReadRSSI: RSSI, error: error)
  352|      0|        }
  353|       |
  354|      0|        func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBPeripheral) {
  355|      0|            if #available(iOS 11.0, tvOS 11.0, watchOS 4.0, *) {
  356|      0|                impl.delegate?.peripheralIsReady(toSendWriteWithoutResponse: impl)
  357|      0|            }
  358|      0|        }
  359|       |        
  360|       |        @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  361|       |        func peripheral(_ peripheral: CBPeripheral,
  362|       |                        didOpen channel: CBL2CAPChannel?,
  363|      0|                        error: Error?) {
  364|      0|            impl.delegate?.peripheral(impl, didOpen: channel, error: error)
  365|      0|        }
  366|       |        
  367|       |        /// Updates the local list of serivces with received ones.
  368|       |        /// - Parameter services: New list of services.
  369|      0|        private func smartCopy(_ services: [CBService]?) {
  370|      0|            guard let services = services else {
  371|      0|                return
  372|      0|            }
  373|      0|            // So far the "smart" copy isn't that smart and just replaces
  374|      0|            // all old references with new ones. The old should still work,
  375|      0|            // as they have the correct native references and isEqual also
  376|      0|            // compares them. But ideally, the copy should only add new
  377|      0|            // attributes, without replacing any existing.
  378|      0|            // TODO: Implement smart copy of services.
  379|      0|            impl.mockServices = services.map { CBMServiceNative($0, in: impl) }            
  380|      0|        }
  381|       |        
  382|       |        /// Returns the wrapper for the native CBService.
  383|       |        /// - Parameter service: The native service.
  384|      0|        private func mock(of service: CBService) -> CBMServiceNative? {
  385|      0|            return impl.mockServices?.first { $0.service == service }
  386|      0|        }
  387|       |        
  388|       |        /// Returns the wrapper for the native CBCharacteristic.
  389|       |        /// - Parameter characteristic: The native characteristic.
  390|      0|        private func mock(of characteristic: CBCharacteristic) -> CBMCharacteristicNative? {
  391|      0|            let service = mock(of: characteristic.service)
  392|      0|            return (service?._characteristics as? [CBMCharacteristicNative])?
  393|      0|                .first { $0.characteristic == characteristic }
  394|      0|        }
  395|       |        
  396|       |        /// Returns the wrapper for the native CBDescriptor.
  397|       |        /// - Parameter descriptor: The native descriptor.
  398|      0|        private func mock(of descriptor: CBDescriptor) -> CBMDescriptorNative? {
  399|      0|            let characteristic = mock(of: descriptor.characteristic)
  400|      0|            return (characteristic?._descriptors as? [CBMDescriptorNative])?
  401|      0|                .first { $0.descriptor == descriptor }
  402|      0|        }
  403|       |        
  404|       |        /// Calls the action with mock service.
  405|       |        /// - Parameters:
  406|       |        ///   - service: The native service.
  407|       |        ///   - action: The action to perform on its mock.
  408|       |        private func usingMock(of service: CBService,
  409|      0|                               action: @escaping (CBMPeripheral, CBMPeripheralDelegate, CBMService) -> ()) {
  410|      0|            if let delegate = impl.delegate,
  411|      0|               let serviceMock = mock(of: service) {
  412|      0|                action(impl, delegate, serviceMock)
  413|      0|            }
  414|      0|        }
  415|       |        
  416|       |        /// Calls the action with mock characteristic.
  417|       |        /// - Parameters:
  418|       |        ///   - service: The native characteristic.
  419|       |        ///   - action: The action to perform on its mock.
  420|       |        private func usingMock(of characteristic: CBCharacteristic,
  421|      0|                               action: @escaping (CBMPeripheral, CBMPeripheralDelegate, CBMCharacteristic) -> ()) {
  422|      0|            usingMock(of: characteristic.service) { p, d, s in
  423|      0|                if let characteristicMock = self.mock(of: characteristic) {
  424|      0|                    action(p, d, characteristicMock)
  425|      0|                }
  426|      0|            }
  427|      0|        }
  428|       |        
  429|       |        /// Calls the action with mock descriptor.
  430|       |        /// - Parameters:
  431|       |        ///   - service: The native descriptor.
  432|       |        ///   - action: The action to perform on its mock.
  433|       |        private func usingMock(of descriptor: CBDescriptor,
  434|      0|                               action: @escaping (CBMPeripheral, CBMPeripheralDelegate, CBMDescriptor) -> ()) {
  435|      0|            usingMock(of: descriptor.characteristic) { p, d, c in
  436|      0|                if let descriptorMock = self.mock(of: descriptor) {
  437|      0|                    action(p, d, descriptorMock)
  438|      0|                }
  439|      0|            }
  440|      0|        }
  441|       |    }
  442|       |    
  443|       |    private var wrapper: CBPeripheralDelegate?
  444|       |    public weak var delegate: CBMPeripheralDelegate? {
  445|      0|        didSet {
  446|      0|            if let _ = delegate {
  447|      0|                // We need to hold a strong reference to the wrapper, otherwise
  448|      0|                // it would be immediately deallocated.
  449|      0|                wrapper = CBPeripheralDelegateWrapper(self)
  450|      0|                peripheral.delegate = wrapper
  451|      0|            } else {
  452|      0|                wrapper = nil
  453|      0|                peripheral.delegate = nil
  454|      0|            }
  455|      0|        }
  456|       |    }
  457|       |    
  458|       |    /// The unique, persistent identifier associated with the peer.
  459|      0|    public override var identifier: UUID {
  460|      0|        return peripheral.identifier
  461|      0|    }
  462|       |    
  463|      0|    public var name: String? {
  464|      0|        return peripheral.name
  465|      0|    }
  466|       |    
  467|      0|    public var state: CBMPeripheralState {
  468|      0|        return peripheral.state
  469|      0|    }
  470|       |    
  471|       |    private var mockServices: [CBMServiceNative]?
  472|      0|    public var services: [CBMService]? {
  473|      0|        return mockServices
  474|      0|    }
  475|       |    
  476|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  477|      0|    public var canSendWriteWithoutResponse: Bool {
  478|      0|        return peripheral.canSendWriteWithoutResponse
  479|      0|    }
  480|       |    
  481|       |    #if !os(macOS)
  482|       |    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  483|      0|    public var ancsAuthorized: Bool {
  484|      0|        return peripheral.ancsAuthorized
  485|      0|    }
  486|       |    #endif
  487|       |    
  488|       |    fileprivate let peripheral: CBPeripheral
  489|       |    
  490|      0|    fileprivate init(_ peripheral: CBPeripheral) {
  491|      0|        self.peripheral = peripheral
  492|      0|    }
  493|       |    
  494|      0|    public func readRSSI() {
  495|      0|        peripheral.readRSSI()
  496|      0|    }
  497|       |    
  498|      0|    public func discoverServices(_ serviceUUIDs: [CBMUUID]?) {
  499|      0|        peripheral.discoverServices(serviceUUIDs)
  500|      0|    }
  501|       |    
  502|       |    public func discoverIncludedServices(_ includedServiceUUIDs: [CBMUUID]?,
  503|      0|                                         for service: CBMService) {
  504|      0|        if let n = service as? CBMServiceNative {
  505|      0|            peripheral.discoverIncludedServices(includedServiceUUIDs, for: n.service)
  506|      0|        }
  507|      0|    }
  508|       |    
  509|       |    public func discoverCharacteristics(_ characteristicUUIDs: [CBMUUID]?,
  510|      0|                                        for service: CBMService) {
  511|      0|        if let n = service as? CBMServiceNative {
  512|      0|            peripheral.discoverCharacteristics(characteristicUUIDs, for: n.service)
  513|      0|        }
  514|      0|    }
  515|       |    
  516|      0|    public func discoverDescriptors(for characteristic: CBMCharacteristic) {
  517|      0|        if let n = characteristic as? CBMCharacteristicNative {
  518|      0|            peripheral.discoverDescriptors(for: n.characteristic)
  519|      0|        }
  520|      0|    }
  521|       |    
  522|      0|    public func readValue(for characteristic: CBMCharacteristic) {
  523|      0|        if let n = characteristic as? CBMCharacteristicNative {
  524|      0|            peripheral.readValue(for: n.characteristic)
  525|      0|        }
  526|      0|    }
  527|       |    
  528|      0|    public func readValue(for descriptor: CBMDescriptor) {
  529|      0|        if let n = descriptor as? CBMDescriptorNative {
  530|      0|            peripheral.readValue(for: n.descriptor)
  531|      0|        }
  532|      0|    }
  533|       |    
  534|       |    @available(iOS 9.0, *)
  535|      0|    public func maximumWriteValueLength(for type: CBMCharacteristicWriteType) -> Int {
  536|      0|        return peripheral.maximumWriteValueLength(for: type)
  537|      0|    }
  538|       |    
  539|       |    public func writeValue(_ data: Data, for characteristic: CBMCharacteristic,
  540|      0|                           type: CBMCharacteristicWriteType) {
  541|      0|        if let n = characteristic as? CBMCharacteristicNative {
  542|      0|            peripheral.writeValue(data, for: n.characteristic, type: type)
  543|      0|        }
  544|      0|    }
  545|       |    
  546|      0|    public func writeValue(_ data: Data, for descriptor: CBMDescriptor) {
  547|      0|        if let n = descriptor as? CBMDescriptorNative {
  548|      0|            peripheral.writeValue(data, for: n.descriptor)
  549|      0|        }
  550|      0|    }
  551|       |    
  552|       |    public func setNotifyValue(_ enabled: Bool,
  553|      0|                               for characteristic: CBMCharacteristic) {
  554|      0|        if let n = characteristic as? CBMCharacteristicNative {
  555|      0|            peripheral.setNotifyValue(enabled, for: n.characteristic)
  556|      0|        }
  557|      0|    }
  558|       |    
  559|       |    #if !os(macOS)
  560|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  561|      0|    public func openL2CAPChannel(_ PSM: CBML2CAPPSM) {
  562|      0|        peripheral.openL2CAPChannel(PSM)
  563|      0|    }
  564|       |    #endif
  565|       |    
  566|      0|    public override var hash: Int {
  567|      0|        return identifier.hashValue
  568|      0|    }
  569|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMPeripheralDelegate.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |public protocol CBMPeripheralDelegate: class {
   34|       |    
   35|       |    /// This method is invoked when the name of peripheral changes.
   36|       |    /// - Parameter peripheral: The peripheral providing this update.
   37|       |    func peripheralDidUpdateName(_ peripheral: CBMPeripheral)
   38|       |    
   39|       |    /// This method is invoked when the `services` of peripheral have been changed.
   40|       |    /// At this point, the designated `CBMService` objects have been invalidated.
   41|       |    /// Services can be re-discovered via `discoverServices(:).
   42|       |    /// - Parameters:
   43|       |    ///   - peripheral: The peripheral providing this update.
   44|       |    ///   - invalidatedServices: The services that have been invalidated.
   45|       |    @available(iOS 7.0, *)
   46|       |    func peripheral(_ peripheral: CBMPeripheral,
   47|       |                    didModifyServices invalidatedServices: [CBMService])
   48|       |    
   49|       |    /// This method returns the result of a `readRSSI(:)` call.
   50|       |    /// - Parameters:
   51|       |    ///   - peripheral: The peripheral providing this update.
   52|       |    ///   - RSSI: The current RSSI of the link.
   53|       |    ///   - error: If an error occurred, the cause of the failure.
   54|       |    func peripheral(_ peripheral: CBMPeripheral,
   55|       |                    didReadRSSI RSSI: NSNumber, error: Error?)
   56|       |    
   57|       |    /// This method returns the result of a `discoverServices(:)` call. If the service(s)
   58|       |    /// were read successfully, they can be retrieved via peripheral's services property.
   59|       |    /// - Parameters:
   60|       |    ///   - peripheral: The peripheral providing this information.
   61|       |    ///   - error: If an error occurred, the cause of the failure.
   62|       |    func peripheral(_ peripheral: CBMPeripheral,
   63|       |                    didDiscoverServices error: Error?)
   64|       |    
   65|       |    /// This method returns the result of a `discoverIncludedServices(:for:) call. If the
   66|       |    /// included service(s) were read successfully, they can be retrieved via service's
   67|       |    /// `includedServices` property.
   68|       |    /// - Parameters:
   69|       |    ///   - peripheral: The peripheral providing this information.
   70|       |    ///   - service: The `CBMService` object containing the included services.
   71|       |    ///   - error: If an error occurred, the cause of the failure.
   72|       |    func peripheral(_ peripheral: CBMPeripheral,
   73|       |                    didDiscoverIncludedServicesFor service: CBMService,
   74|       |                    error: Error?)
   75|       |    
   76|       |    /// This method returns the result of a `discoverCharacteristics(:for:)` call. If the
   77|       |    /// characteristic(s) were read successfully, they can be retrieved via service's
   78|       |    /// `characteristics` property.
   79|       |    /// - Parameters:
   80|       |    ///   - peripheral: The peripheral providing this information.
   81|       |    ///   - service: The `CBMService` object containing the characteristic(s).
   82|       |    ///   - error: If an error occurred, the cause of the failure.
   83|       |    func peripheral(_ peripheral: CBMPeripheral,
   84|       |                    didDiscoverCharacteristicsFor service: CBMService,
   85|       |                    error: Error?)
   86|       |    
   87|       |    /// This method returns the result of a `discoverDescriptors(for:)` call. If the
   88|       |    /// descriptors were read successfully, they can be retrieved via characteristic's
   89|       |    /// `descriptors` property.
   90|       |    /// - Parameters:
   91|       |    ///   - peripheral: The peripheral providing this information.
   92|       |    ///   - characteristic: A `CBMCharacteristic` object.
   93|       |    ///   - error: If an error occurred, the cause of the failure.
   94|       |    func peripheral(_ peripheral: CBMPeripheral,
   95|       |                    didDiscoverDescriptorsFor characteristic: CBMCharacteristic,
   96|       |                    error: Error?)
   97|       |    
   98|       |    /// This method returns the result of a `setNotifyValue(:for:) call. 
   99|       |    /// - Parameters:
  100|       |    ///   - peripheral: The peripheral providing this information.
  101|       |    ///   - characteristic: A `CBMCharacteristic` object.
  102|       |    ///   - error: If an error occurred, the cause of the failure.
  103|       |    func peripheral(_ peripheral: CBMPeripheral,
  104|       |                    didUpdateNotificationStateFor characteristic: CBMCharacteristic,
  105|       |                    error: Error?)
  106|       |    
  107|       |    /// This method is invoked after a `readValue(for:) call, or upon receipt of a
  108|       |    /// notification/indication.
  109|       |    /// - Parameters:
  110|       |    ///   - peripheral: The peripheral providing this information.
  111|       |    ///   - characteristic: A `CBMCharacteristic` object.
  112|       |    ///   - error: If an error occurred, the cause of the failure.
  113|       |    func peripheral(_ peripheral: CBMPeripheral,
  114|       |                    didUpdateValueFor characteristic: CBMCharacteristic,
  115|       |                    error: Error?)
  116|       |    
  117|       |    /// This method returns the result of a `readValue(for:)` call.
  118|       |    /// - Parameters:
  119|       |    ///   - peripheral: The peripheral providing this information.
  120|       |    ///   - descriptor: A `CBDescriptorType` object.
  121|       |    ///   - error: If an error occurred, the cause of the failure.
  122|       |    func peripheral(_ peripheral: CBMPeripheral,
  123|       |                    didUpdateValueFor descriptor: CBMDescriptor, error: Error?)
  124|       |    
  125|       |    /// This method returns the result of a `writeValue(:for:type:)` call, when the
  126|       |    /// `.withResponse` type is used.
  127|       |    ///
  128|       |    /// - Important: On iOS 10 this callback was also incorrectly called for
  129|       |    ///             `.withoutResponse` type.
  130|       |    /// - Parameters:
  131|       |    ///   - peripheral: The peripheral providing this information.
  132|       |    ///   - characteristic: A `CBMCharacteristic` object.
  133|       |    ///   - error: If an error occurred, the cause of the failure.
  134|       |    func peripheral(_ peripheral: CBMPeripheral,
  135|       |                    didWriteValueFor characteristic: CBMCharacteristic,
  136|       |                    error: Error?)
  137|       |    
  138|       |    /// This method returns the result of a `writeValue(:for:)` call.
  139|       |    /// - Parameters:
  140|       |    ///   - peripheral: The peripheral providing this information.
  141|       |    ///   - descriptor: A `CBDescriptorType` object.
  142|       |    ///   - error: If an error occurred, the cause of the failure.
  143|       |    func peripheral(_ peripheral: CBMPeripheral,
  144|       |                    didWriteValueFor descriptor: CBMDescriptor, error: Error?)
  145|       |    
  146|       |    /// This method is invoked after a failed call to `writeValue(:for:type:), when
  147|       |    /// peripheral is again ready to send characteristic value updates.
  148|       |    /// - Parameter peripheral: The peripheral providing this update.
  149|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  150|       |    func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBMPeripheral)
  151|       |
  152|       |    /// This method returns the result of a `openL2CAPChannel(:)` call.
  153|       |    /// - Parameters:
  154|       |    ///   - peripheral: The peripheral providing this information.
  155|       |    ///   - channel: A `CBL2CAPChannel` object.
  156|       |    ///   - error: If an error occurred, the cause of the failure.
  157|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  158|       |    func peripheral(_ peripheral: CBMPeripheral,
  159|       |                    didOpen channel: CBML2CAPChannel?, error: Error?)
  160|       |}
  161|       |
  162|       |public extension CBMPeripheralDelegate {
  163|       |    
  164|      0|    func peripheralDidUpdateName(_ p: CBMPeripheral) {
  165|      0|        // optional method
  166|      0|    }
  167|       |
  168|       |    func peripheral(_ peripheral: CBMPeripheral,
  169|      0|                    didModifyServices invalidatedServices: [CBMService]) {
  170|      0|        // optional method
  171|      0|    }
  172|       |    
  173|       |    func peripheral(_ peripheral: CBMPeripheral,
  174|      0|                    didReadRSSI RSSI: NSNumber, error: Error?) {
  175|      0|        // optional method
  176|      0|    }
  177|       |
  178|       |    func peripheral(_ peripheral: CBMPeripheral,
  179|      0|                    didDiscoverServices error: Error?) {
  180|      0|        // optional method
  181|      0|    }
  182|       |
  183|       |    func peripheral(_ peripheral: CBMPeripheral,
  184|      0|                    didDiscoverIncludedServicesFor service: CBMService, error: Error?) {
  185|      0|        // optional method
  186|      0|    }
  187|       |
  188|       |    func peripheral(_ peripheral: CBMPeripheral,
  189|      0|                    didDiscoverCharacteristicsFor service: CBMService, error: Error?) {
  190|      0|        // optional method
  191|      0|    }
  192|       |
  193|       |    func peripheral(_ peripheral: CBMPeripheral,
  194|      0|                    didUpdateValueFor characteristic: CBMCharacteristic, error: Error?) {
  195|      0|        // optional method
  196|      0|    }
  197|       |
  198|       |    func peripheral(_ peripheral: CBMPeripheral,
  199|      0|                    didWriteValueFor characteristic: CBMCharacteristic, error: Error?) {
  200|      0|        // optional method
  201|      0|    }
  202|       |
  203|       |    func peripheral(_ peripheral: CBMPeripheral,
  204|      0|                    didUpdateNotificationStateFor characteristic: CBMCharacteristic, error: Error?) {
  205|      0|        // optional method
  206|      0|    }
  207|       |    
  208|       |    func peripheral(_ peripheral: CBMPeripheral,
  209|      0|                    didDiscoverDescriptorsFor characteristic: CBMCharacteristic, error: Error?) {
  210|      0|        // optional method
  211|      0|    }
  212|       |    
  213|       |    func peripheral(_ peripheral: CBMPeripheral,
  214|      0|                    didUpdateValueFor descriptor: CBMDescriptor, error: Error?) {
  215|      0|        // optional method
  216|      0|    }
  217|       |    
  218|       |    func peripheral(_ peripheral: CBMPeripheral,
  219|      0|                    didWriteValueFor descriptor: CBMDescriptor, error: Error?) {
  220|      0|        // optional method
  221|      0|    }
  222|       |
  223|      0|    func peripheralIsReady(toSendWriteWithoutResponse peripheral: CBMPeripheral) {
  224|      0|        // optional method
  225|      0|    }
  226|       |
  227|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  228|       |    func peripheral(_ peripheral: CBMPeripheral,
  229|      0|                    didOpen channel: CBML2CAPChannel?, error: Error?) {
  230|      0|        // optional method
  231|      0|    }
  232|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMPeripheralSpec.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |/// The approximate mock device proximity.
   34|       |public enum CBMProximity {
   35|       |    /// The device will have RSSI values around -40 dBm.
   36|       |    case near
   37|       |    /// The device will have RSSI values around -70 dBm.
   38|       |    case immediate
   39|       |    /// The device is far, will have RSSI values around -100 dBm.
   40|       |    case far
   41|       |    /// The device is out of range.
   42|       |    case outOfRange
   43|       |    
   44|     44|    internal var RSSI: Int {
   45|     44|        switch self {
   46|     44|        case .near:       return -40
   47|     44|        case .immediate:  return -70
   48|     44|        case .far:        return -100
   49|     44|        case .outOfRange: return 127
   50|     44|        }
   51|     44|    }
   52|       |}
   53|       |
   54|       |/// The peripheral instance specification.
   55|       |public class CBMPeripheralSpec {
   56|       |    /// The peripheral identifier.
   57|       |    public let identifier: UUID
   58|       |    /// The name of the peripheral usually returned by Device Name
   59|       |    /// characteristic.
   60|       |    public internal(set) var name: String?
   61|       |    /// How far the device is.
   62|       |    public internal(set) var proximity: CBMProximity
   63|       |    /// Should the mock peripheral appear in scan results when it's
   64|       |    /// connected.
   65|       |    public let isAdvertisingWhenConnected: Bool
   66|       |    
   67|       |    /// The device's advertising data.
   68|       |    /// Make sure to include `CBAdvertisementDataIsConnectable` if
   69|       |    /// the device is connectable.
   70|       |    public let advertisementData: [String : Any]?
   71|       |    /// The advertising interval.
   72|       |    public let advertisingInterval: TimeInterval?
   73|       |    
   74|       |    /// List of services with implementation.
   75|       |    public internal(set) var services: [CBMServiceMock]?
   76|       |    /// The connection interval.
   77|       |    public let connectionInterval: TimeInterval?
   78|       |    /// The MTU (Maximum Transfer Unit). Min value is 23, max 517.
   79|       |    /// The maximum value length for Write Without Response is
   80|       |    /// MTU - 3 bytes.
   81|       |    public let mtu: Int?
   82|       |    /// The delegate that will handle connection requests.
   83|       |    public let connectionDelegate: CBMPeripheralSpecDelegate?
   84|       |    /// A flag indicating whether the device is connected.
   85|     53|    public var isConnected: Bool {
   86|     53|        return virtualConnections > 0
   87|     53|    }
   88|       |    /// Number of virtual connections to this peripheral. A peripheral
   89|       |    /// may be connected using multiple central managers in one or
   90|       |    /// multiple apps. When this drops to 0, the device is physically
   91|       |    /// disconnected.
   92|       |    internal var virtualConnections: Int
   93|       |    
   94|       |    private init(
   95|       |            identifier: UUID,
   96|       |            name: String?,
   97|       |            proximity: CBMProximity,
   98|       |            isInitiallyConnected: Bool,
   99|       |            isAdvertisingWhenConnected: Bool,
  100|       |            advertisementData: [String : Any]?,
  101|       |            advertisingInterval: TimeInterval?,
  102|       |            services: [CBMServiceMock]?,
  103|       |            connectionInterval: TimeInterval?,
  104|       |            mtu: Int?,
  105|      2|            connectionDelegate: CBMPeripheralSpecDelegate?) {
  106|      2|        self.identifier = identifier
  107|      2|        self.name = name
  108|      2|        self.proximity = proximity
  109|      2|        self.virtualConnections = isInitiallyConnected ? 1 : 0
  110|      2|        self.isAdvertisingWhenConnected = isAdvertisingWhenConnected
  111|      2|        self.advertisementData = advertisementData
  112|      2|        self.advertisingInterval = advertisingInterval
  113|      2|        self.services = services
  114|      2|        self.connectionInterval = connectionInterval
  115|      2|        self.mtu = mtu
  116|      2|        self.connectionDelegate = connectionDelegate
  117|      2|    }
  118|       |    
  119|       |    /// Creates a `MockPeripheral.Builder` instance.
  120|       |    /// Use builder methods to customize your device and call `build()` to
  121|       |    /// return the `MockPeripheral` object.
  122|       |    /// - Parameters:
  123|       |    ///   - identifier: The peripheral identifier. If not given, a random
  124|       |    ///                 UUID will be used.
  125|       |    ///   - proximity: Approximate distance to the device. By default set
  126|       |    ///                to `.immediate`.
  127|       |    public static func simulatePeripheral(identifier: UUID = UUID(),
  128|      2|                                          proximity: CBMProximity = .immediate) -> Builder {
  129|      2|        return Builder(identifier: identifier,
  130|      2|                       proximity: proximity)
  131|      2|    }
  132|       |    
  133|       |    /// Simulates the situation when another application on the device
  134|       |    /// connects to the device.
  135|       |    ///
  136|       |    /// If `isAdvertisingWhenConnected` flag is set to <i>false</i>, the
  137|       |    /// device will stop showing up on scan results.
  138|       |    ///
  139|       |    /// A manager registered for connection event will receive an event.
  140|       |    ///
  141|       |    /// Connected devices are be available for managers using
  142|       |    /// `retrieveConnectedPeripherals(withServices:)`.
  143|      0|    public func simulateConnection() {
  144|      0|        CBMCentralManagerMock.peripheralDidConnect(self)
  145|      0|    }
  146|       |    
  147|       |    /// Simulates a situation when the peripheral disconnection from
  148|       |    /// the device.
  149|       |    ///
  150|       |    /// All connected mock central managers will receive
  151|       |    /// `peripheral(:didDisconnected:error)` callback.
  152|       |    /// - Parameter error: The disconnection reason. Use `CBMError` or
  153|       |    ///                    `CBMATTError` errors.
  154|      7|    public func simulateDisconnection(withError error: Error = CBMError(.peripheralDisconnected)) {
  155|      7|        CBMCentralManagerMock.peripheral(self, didDisconnectWithError: error)
  156|      7|    }
  157|       |    
  158|       |    /// Simulates a reset of the peripheral. The peripheral will start
  159|       |    /// advertising again (if advertising was enabled) immediately.
  160|       |    /// Connected central managers will be notified after the supervision
  161|       |    /// timeout is over.
  162|      4|    public func simulateReset() {
  163|      4|        connectionDelegate?.reset()
  164|      4|        simulateDisconnection(withError: CBMError(.connectionTimeout))
  165|      4|    }
  166|       |    
  167|       |    /// Simulates a situation when the device changes its services.
  168|       |    /// Only services that were not in the previous list of services
  169|       |    /// will be reported as invalidated.
  170|       |    ///
  171|       |    /// The device must be connectable, otherwise this method does
  172|       |    /// nothing.
  173|       |    /// - Important: In the mock implementation the order of services
  174|       |    ///              is irrelevant. This is in contrary to the physical
  175|       |    ///              Bluetooth LE device, where handle numbers depend
  176|       |    ///              on order of the services in the attribute database.
  177|       |    /// - Parameters:
  178|       |    ///   - newName: The new device name after change.
  179|       |    ///   - newServices: The new services after change.
  180|       |    public func simulateServiceChange(newName: String?,
  181|      1|                                      newServices: [CBMServiceMock]) {
  182|      1|        guard let _ = connectionDelegate else {
  183|      0|            return
  184|      1|        }
  185|      1|        CBMCentralManagerMock.peripheral(self, didUpdateName: newName,
  186|      1|                                        andServices: newServices)
  187|      1|    }
  188|       |    
  189|       |    /// Simulates a situation when the peripheral was moved closer
  190|       |    /// or away from the phone.
  191|       |    ///
  192|       |    /// If the proximity is changed to `.outOfRange`, the peripheral will
  193|       |    /// be disconnected and will not appear on scan results.
  194|       |    /// - Parameter proximity: The new peripheral proximity.
  195|     47|    public func simulateProximityChange(_ proximity: CBMProximity) {
  196|     47|        CBMCentralManagerMock.proximity(of: self, didChangeTo: proximity)
  197|     47|    }
  198|       |    
  199|       |    /// Simulates a notification/indication sent from the peripheral.
  200|       |    ///
  201|       |    /// All central managers that have enabled notifications on it
  202|       |    /// will receive `peripheral(:didUpdateValueFor:error)`.
  203|       |    /// - Parameters:
  204|       |    ///   - data: The notification/indication data.
  205|       |    ///   - characteristic: The characteristic from which a
  206|       |    ///                     notification or indication is to be sent.
  207|       |    public func simulateValueUpdate(_ data: Data,
  208|    235|                                    for characteristic: CBMCharacteristicMock) {
  209|    235|        guard let services = services, services.contains(where: {
  210|    235|                  $0.characteristics?.contains(characteristic) ?? false
  211|    235|              }) else {
  212|      0|            return
  213|    235|        }
  214|    235|        characteristic.value = data
  215|    235|        CBMCentralManagerMock.peripheral(self, didUpdateValueFor: characteristic)
  216|    235|    }
  217|       |    
  218|       |    public class Builder {
  219|       |        /// The peripheral identifier.
  220|       |        private var identifier: UUID
  221|       |        /// The name of the peripheral cached during previous session.
  222|       |        /// This may be <i>nil<i/> to simulate a newly discovered devices.
  223|       |        private var name: String?
  224|       |        /// How far the device is.
  225|       |        private var proximity: CBMProximity
  226|       |             
  227|       |        /// The device's advertising data.
  228|       |        /// Make sure to include `CBAdvertisementDataIsConnectable` with
  229|       |        /// value <i>true</i> if the device is connectable.
  230|       |        private var advertisementData: [String : Any]? = nil
  231|       |        /// The advertising interval, in seconds.
  232|      2|        private var advertisingInterval: TimeInterval? = 0.100
  233|       |        
  234|       |        /// Should the mock peripheral appear in scan results when it's
  235|       |        /// connected.
  236|       |        private var isAdvertisingWhenConnected: Bool = false
  237|       |        /// A flag indicating whether the device is initially connected
  238|       |        /// to the central (using some other application).
  239|       |        private var isInitiallyConnected: Bool = false
  240|       |        
  241|       |        /// List of services with implementation.
  242|       |        private var services: [CBMServiceMock]? = nil
  243|       |        /// The connection interval, in seconds.
  244|       |        private var connectionInterval: TimeInterval? = nil
  245|       |        /// The MTU (Maximul Transfer Unit). Min value is 23, max 517.
  246|       |        /// The maximum value length for Write Without Response is
  247|       |        /// MTU - 3 bytes.
  248|       |        private var mtu: Int? = nil
  249|       |        /// The delegate that will handle connection requests.
  250|       |        private var connectionDelegate: CBMPeripheralSpecDelegate?
  251|       |        
  252|      2|        fileprivate init(identifier: UUID, proximity: CBMProximity) {
  253|      2|            self.identifier = identifier
  254|      2|            self.proximity = proximity
  255|      2|        }
  256|       |        
  257|       |        /// Makes the device advertising given data with specified advertising
  258|       |        /// interval.
  259|       |        /// - Parameters:
  260|       |        ///   - advertisementData: The advertising data.
  261|       |        ///   - interval: Advertising interval, in seconds.
  262|       |        ///   - advertisingWhenConnected: If <i>true</i>, the device will also
  263|       |        ///                               be returned in scan results when
  264|       |        ///                               connected. By default set to
  265|       |        ///                               <i>false</i>.
  266|       |        /// - Returns: The builder.
  267|       |        public func advertising(advertisementData: [String : Any],
  268|       |                                withInterval interval: TimeInterval = 0.100,
  269|      2|                                alsoWhenConnected advertisingWhenConnected: Bool = false) -> Builder {
  270|      2|            self.advertisementData = advertisementData
  271|      2|            self.advertisingInterval = interval
  272|      2|            self.isAdvertisingWhenConnected = advertisingWhenConnected
  273|      2|            return self
  274|      2|        }
  275|       |        
  276|       |        /// Makes the device connectable, but not connected at the moment
  277|       |        /// of initialization.
  278|       |        /// - Parameters:
  279|       |        ///   - name: The device name, returned by Device Name characteristic.
  280|       |        ///   - services: List of services that will be returned from service
  281|       |        ///               discovery.
  282|       |        ///   - connectionDelegate: The connection delegate that will handle
  283|       |        ///                         GATT requests.
  284|       |        ///   - connectionInterval: Connection interval, in seconds.
  285|       |        ///   - mtu: The MTU (Maximum Transfer Unit). Min 23 (default), max 517.
  286|       |        ///          The maximum value length for Write Without Response is
  287|       |        ///          MTU - 3 bytes (3 bytes are used by GATT for handle and
  288|       |        ///          command).
  289|       |        public func connectable(name: String,
  290|       |                                services: [CBMServiceMock],
  291|       |                                delegate: CBMPeripheralSpecDelegate?,
  292|       |                                connectionInterval: TimeInterval = 0.045,
  293|      2|                                mtu: Int = 23) -> Builder {
  294|      2|            self.name = name
  295|      2|            self.services = services
  296|      2|            self.connectionDelegate = delegate
  297|      2|            self.connectionInterval = connectionInterval
  298|      2|            self.mtu = max(23, min(517, mtu))
  299|      2|            self.isInitiallyConnected = false
  300|      2|            return self
  301|      2|        }
  302|       |        
  303|       |        /// Makes the device connectable, and also marks already connected
  304|       |        /// by some other application. Such device, if not advertising,
  305|       |        /// can be obtained using `retrieveConnectedPeripherals(withServices:)`.
  306|       |        /// - Parameters:
  307|       |        ///   - name: The device name, returned by Device Name characteristic.
  308|       |        ///   - services: List of services that will be returned from service
  309|       |        ///               discovery.
  310|       |        ///   - connectionDelegate: The connection delegate that will handle
  311|       |        ///                         GATT requests.
  312|       |        ///   - connectionInterval: Connection interval, in seconds.
  313|       |        ///   - mtu: The MTU (Maximum Transfer Unit). Min 23 (default), max 517.
  314|       |        ///          The maximum value length for Write Without Response is
  315|       |        ///          MTU - 3 bytes (3 bytes are used by GATT for handle and
  316|       |        ///          command).
  317|       |        public func connected(name: String,
  318|       |                              services: [CBMServiceMock],
  319|       |                              delegate: CBMPeripheralSpecDelegate?,
  320|       |                              connectionInterval: TimeInterval = 0.045,
  321|      0|                              mtu: Int = 23)-> Builder {
  322|      0|            self.name = name
  323|      0|            self.services = services
  324|      0|            self.connectionDelegate = delegate
  325|      0|            self.connectionInterval = connectionInterval
  326|      0|            self.mtu = mtu
  327|      0|            self.isInitiallyConnected = true
  328|      0|            return self
  329|      0|        }
  330|       |        
  331|       |        /// Builds the `MockPeripheral` object.
  332|      2|        public func build() -> CBMPeripheralSpec {
  333|      2|            return CBMPeripheralSpec(
  334|      2|                identifier: identifier,
  335|      2|                name: name,
  336|      2|                proximity: proximity,
  337|      2|                isInitiallyConnected: isInitiallyConnected,
  338|      2|                isAdvertisingWhenConnected: isAdvertisingWhenConnected,
  339|      2|                advertisementData: advertisementData,
  340|      2|                advertisingInterval: advertisingInterval,
  341|      2|                services: services,
  342|      2|                connectionInterval: connectionInterval,
  343|      2|                mtu: mtu,
  344|      2|                connectionDelegate: connectionDelegate
  345|      2|            )
  346|      2|        }
  347|       |    }
  348|       |}
  349|       |
  350|       |extension CBMPeripheralSpec: Equatable {
  351|       |    
  352|    267|    public static func == (lhs: CBMPeripheralSpec, rhs: CBMPeripheralSpec) -> Bool {
  353|    267|        return lhs.identifier == rhs.identifier
  354|    267|    }
  355|       |    
  356|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMPeripheralSpecDelegate.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |public protocol CBMPeripheralSpecDelegate {
   34|       |
   35|       |    /// This method is called when the mock peripheral has been reset.
   36|       |    /// It should reset all values to the initial state.
   37|       |    func reset()
   38|       |
   39|       |    /// This method will be called when a connect request was initiated from a
   40|       |    /// mock central manager.
   41|       |    /// - Parameter peripheral: The peripheral specification to handle connection.
   42|       |    /// - Returns: Success or an error. The error will be returned using
   43|       |    ///            `centralManager(:didFailToConnect:error:)`.
   44|       |    func peripheralDidReceiveConnectionRequest(_ peripheral: CBMPeripheralSpec)
   45|       |        -> Result<Void, Error>
   46|       |
   47|       |    /// This method will be called when disconnection was initiated from a
   48|       |    /// mock central manager or peripheral side.
   49|       |    /// - Parameters:
   50|       |    ///   - peripheral: The peripheral specification that is disconnected.
   51|       |    ///   - error: An optional reason of disconnection, in case it was initiated
   52|       |    ///            from the peripheral side.
   53|       |    func peripheral(_ peripheral: CBMPeripheralSpec, didDisconnect error: Error?)
   54|       |
   55|       |    /// This method will be called when service discovery was initiated using a
   56|       |    /// mock central manager. When success is returned, the services will be
   57|       |    /// returned automatically based on the device specification.
   58|       |    /// - Parameters:
   59|       |    ///   - peripheral: The target device.
   60|       |    ///   - serviceUUIDs: Optional services requested.
   61|       |    /// - Returns: Success, or a service discovery error. The error will be reported
   62|       |    ///            using `peripheral(:didDiscoverServices:)`.
   63|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
   64|       |                    didReceiveServiceDiscoveryRequest serviceUUIDs: [CBMUUID]?)
   65|       |        -> Result<Void, Error>
   66|       |
   67|       |    /// This method will be called when service discovery of included services was
   68|       |    /// initiated using a mock central manager. When success is returned, the services
   69|       |    /// will be returned automatically based on the device specification.
   70|       |    /// - Parameters:
   71|       |    ///   - peripheral: The target device.
   72|       |    ///   - serviceUUIDs: Optional services requested.
   73|       |    ///   - service: The primary service.
   74|       |    /// - Returns: Success, or a service discovery error. The error will be reported
   75|       |    ///            using `peripheral(:didDiscoverIncludedServices:)`.
   76|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
   77|       |                    didReceiveIncludedServiceDiscoveryRequest serviceUUIDs: [CBMUUID]?,
   78|       |                    for service: CBMService)
   79|       |        -> Result<Void, Error>
   80|       |
   81|       |    /// This method will be called when characteristic discovery was initiated using a
   82|       |    /// mock central manager. When success is returned, the characteristics will be returned
   83|       |    /// automatically based on the device specification.
   84|       |    /// - Parameters:
   85|       |    ///   - peripheral: The target device.
   86|       |    ///   - characteristicUUIDs: Optional characteristics requested.
   87|       |    ///   - service: The parent service.
   88|       |    /// - Returns: Success, or a service discovery error. The error will be reported
   89|       |    ///            using `peripheral(:didDiscoverCharacteristics:)`.
   90|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
   91|       |                    didReceiveCharacteristicsDiscoveryRequest characteristicUUIDs: [CBMUUID]?,
   92|       |                    for service: CBMService)
   93|       |        -> Result<Void, Error>
   94|       |
   95|       |    /// This method will be called when descriptor discovery was initiated using a
   96|       |    /// mock central manager. When success is returned, the descriptors will be returned
   97|       |    /// automatically based on the device specification.
   98|       |    /// - Parameters:
   99|       |    ///   - peripheral: The target device.
  100|       |    ///   - characteristic: The parent characteristic.
  101|       |    /// - Returns: Success, or a service discovery error. The error will be reported
  102|       |    ///            using `peripheral(:didDiscoverDescriptors:)`.
  103|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  104|       |                    didReceiveDescriptorsDiscoveryRequestFor characteristic: CBMCharacteristic)
  105|       |        -> Result<Void, Error>
  106|       |
  107|       |    /// This method will be called when read request has been initiated from a mock
  108|       |    /// central manager.
  109|       |    /// - Parameters:
  110|       |    ///   - peripheral: The target peripheral specification.
  111|       |    ///   - characteristic: The characteristic, which value should be returned.
  112|       |    /// - Returns: When success, the characteristic value should be returned. In case
  113|       |    ///            of a failure, the returned error will be returned to the
  114|       |    ///            `peripheral(:didUpdateValueFor:error:)`.
  115|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  116|       |                    didReceiveReadRequestFor characteristic: CBMCharacteristic)
  117|       |        -> Result<Data, Error>
  118|       |
  119|       |    /// This method will be called when read request has been initiated from a mock
  120|       |    /// central manager.
  121|       |    /// - Parameters:
  122|       |    ///   - peripheral: The target peripheral specification.
  123|       |    ///   - descriptor: The descriptor, which value should be returned.
  124|       |    /// - Returns: When success, the descriptor value should be returned. In case
  125|       |    ///            of a failure, the returned error will be returned to the
  126|       |    ///            `peripheral(:didUpdateValueFor:error:)`.
  127|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  128|       |                    didReceiveReadRequestFor descriptor: CBMDescriptor)
  129|       |        -> Result<Data, Error>
  130|       |
  131|       |    /// This method will be called when write request has been initiated from a mock
  132|       |    /// central manager.
  133|       |    /// - Parameters:
  134|       |    ///   - peripheral: The target peripheral specification.
  135|       |    ///   - characteristic: The target characteristic.
  136|       |    ///   - data: The data written.
  137|       |    /// - Returns: Success, or the reason of failure. The returned error will be
  138|       |    ///            returned to the `peripheral(:didWriteValueFor:error:)`.
  139|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  140|       |                    didReceiveWriteRequestFor characteristic: CBMCharacteristic,
  141|       |                    data: Data)
  142|       |        -> Result<Void, Error>
  143|       |
  144|       |    /// This method will be called when write command has been initiated from a mock
  145|       |    /// central manager. Write command is also known as write without response.
  146|       |    /// - Parameters:
  147|       |    ///   - peripheral: The target peripheral specification.
  148|       |    ///   - characteristic: The target characteristic.
  149|       |    ///   - data: The data written.
  150|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  151|       |                    didReceiveWriteCommandFor characteristic: CBMCharacteristic,
  152|       |                    data: Data)
  153|       |
  154|       |    /// This method will be called when write request has been initiated from a mock
  155|       |    /// central manager.
  156|       |    /// - Parameters:
  157|       |    ///   - peripheral: The target peripheral specification.
  158|       |    ///   - descriptor: The target descriptor.
  159|       |    ///   - data: The data written.
  160|       |    /// - Returns: Success, or the reason of failure. The returned error will be
  161|       |    ///            returned to the `peripheral(:didWriteValueFor:error:)`.
  162|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  163|       |                    didReceiveWriteRequestFor descriptor: CBMDescriptor,
  164|       |                    data: Data)
  165|       |        -> Result<Void, Error>
  166|       |
  167|       |    /// This method will be called when notifications or indications were enabled
  168|       |    /// or disabled on the given characteristic using a mock central manager.
  169|       |    /// - Parameters:
  170|       |    ///   - peripheral: The target peripheral specification.
  171|       |    ///   - enabled: Whether notifications or indications were enabled or disabled.
  172|       |    ///   - characteristic: The target characteristic.
  173|       |    /// - Returns: Success, or the reason of a failure.
  174|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  175|       |                    didReceiveSetNotifyRequest enabled: Bool,
  176|       |                    for characteristic: CBMCharacteristic)
  177|       |        -> Result<Void, Error>
  178|       |}
  179|       |
  180|       |public extension CBMPeripheralSpecDelegate {
  181|       |
  182|      0|    func reset() {
  183|      0|        // Empty default implementation
  184|      0|    }
  185|       |
  186|       |    func peripheralDidReceiveConnectionRequest(_ peripheral: CBMPeripheralSpec)
  187|     34|        -> Result<Void, Error> {
  188|     34|            return .success(())
  189|     34|    }
  190|       |    
  191|     33|    func peripheral(_ peripheral: CBMPeripheralSpec, didDisconnect error: Error?) {
  192|     33|        assert(peripheral.virtualConnections == 0)
  193|     33|    }
  194|       |    
  195|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  196|       |                    didReceiveServiceDiscoveryRequest serviceUUIDs: [CBMUUID]?)
  197|     21|        -> Result<Void, Error> {
  198|     21|            return .success(())
  199|     21|    }
  200|       |    
  201|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  202|       |                    didReceiveIncludedServiceDiscoveryRequest serviceUUIDs: [CBMUUID]?,
  203|       |                    for service: CBMService)
  204|      0|        -> Result<Void, Error> {
  205|      0|            return .success(())
  206|      0|    }
  207|       |        
  208|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  209|       |                    didReceiveCharacteristicsDiscoveryRequest characteristicUUIDs: [CBMUUID]?,
  210|       |                    for service: CBMService)
  211|     22|        -> Result<Void, Error> {
  212|     22|            return .success(())
  213|     22|   }
  214|       |            
  215|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  216|       |                    didReceiveDescriptorsDiscoveryRequestFor characteristic: CBMCharacteristic)
  217|      0|        -> Result<Void, Error> {
  218|      0|            return .success(())
  219|      0|   }
  220|       |    
  221|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  222|       |                    didReceiveReadRequestFor characteristic: CBMCharacteristic)
  223|      0|        -> Result<Data, Error> {
  224|      0|            return .failure(CBMATTError(.readNotPermitted))
  225|      0|   }
  226|       |        
  227|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  228|       |                    didReceiveReadRequestFor descriptor: CBMDescriptor)
  229|      0|        -> Result<Data, Error> {
  230|      0|            return .failure(CBMATTError(.readNotPermitted))
  231|      0|    }
  232|       |
  233|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  234|       |                    didReceiveWriteRequestFor characteristic: CBMCharacteristic,
  235|       |                    data: Data)
  236|      0|        -> Result<Void, Error> {
  237|      0|            return .failure(CBMATTError(.writeNotPermitted))
  238|      0|    }
  239|       |
  240|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  241|       |                    didReceiveWriteCommandFor characteristic: CBMCharacteristic,
  242|      2|                    data: Data) {
  243|      2|        // Empty default implementation
  244|      2|    }
  245|       |
  246|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  247|       |                    didReceiveWriteRequestFor descriptor: CBMDescriptor,
  248|       |                    data: Data)
  249|      0|        -> Result<Void, Error> {
  250|      0|            return .failure(CBATTError(.writeNotPermitted))
  251|      0|    }
  252|       |    
  253|       |    func peripheral(_ peripheral: CBMPeripheralSpec,
  254|       |                    didReceiveSetNotifyRequest enabled: Bool,
  255|       |                    for characteristic: CBMCharacteristic)
  256|     16|        -> Result<Void, Error> {
  257|     16|            if !characteristic.properties
  258|     16|                .isDisjoint(with: [
  259|     16|                    .notify,
  260|     16|                    .indicate,
  261|     16|                    .notifyEncryptionRequired,
  262|     16|                    .indicateEncryptionRequired]) {
  263|     16|                return .success(())
  264|     16|            } else {
  265|      0|                return .failure(CBMError(.invalidHandle))
  266|      0|            }
  267|      0|    }
  268|       |}

/Users/Andrea/Library/Developer/Xcode/DerivedData/LittleBlueTooth-eqgsjrwzxjxdzkcqhbowlwlvpaph/SourcePackages/checkouts/IOS-CoreBluetooth-Mock/CoreBluetoothMock/Classes/CBMServiceTypes.swift:
    1|       |/*
    2|       |* Copyright (c) 2020, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification,
    6|       |* are permitted provided that the following conditions are met:
    7|       |*
    8|       |* 1. Redistributions of source code must retain the above copyright notice, this
    9|       |*    list of conditions and the following disclaimer.
   10|       |*
   11|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this
   12|       |*    list of conditions and the following disclaimer in the documentation and/or
   13|       |*    other materials provided with the distribution.
   14|       |*
   15|       |* 3. Neither the name of the copyright holder nor the names of its contributors may
   16|       |*    be used to endorse or promote products derived from this software without
   17|       |*    specific prior written permission.
   18|       |*
   19|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   20|       |* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   21|       |* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
   22|       |* IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
   23|       |* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   24|       |* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   25|       |* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
   26|       |* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
   27|       |* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   28|       |* POSSIBILITY OF SUCH DAMAGE.
   29|       |*/
   30|       |
   31|       |import CoreBluetooth
   32|       |
   33|       |open class CBMService: CBMAttribute {
   34|       |    internal let identifier: UUID
   35|       |    private let _uuid: CBMUUID
   36|       |    
   37|       |    internal var _includedServices: [CBMService]?
   38|       |    internal var _characteristics: [CBMCharacteristic]?
   39|       |
   40|       |    /// A back-pointer to the peripheral this service belongs to.
   41|       |    open internal(set) unowned var peripheral: CBMPeripheral
   42|       |    
   43|       |    /// The type of the service (primary or secondary).
   44|       |    open fileprivate(set) var isPrimary: Bool
   45|       |    
   46|       |    /// The Bluetooth UUID of the attribute.
   47|    260|    open override var uuid: CBMUUID {
   48|    260|        return _uuid
   49|    260|    }
   50|       |    
   51|       |    /// A list of included services that have so far been discovered in this service.
   52|      0|    open var includedServices: [CBMService]? {
   53|      0|        return _includedServices
   54|      0|    }
   55|       |
   56|       |    /// A list of characteristics that have so far been discovered in this service.
   57|    388|    open var characteristics: [CBMCharacteristic]? {
   58|    388|        return _characteristics
   59|    388|    }
   60|       |    
   61|       |    /// Returns a service, initialized with a service type and UUID.
   62|       |    /// - Parameters:
   63|       |    ///   - uuid: The Bluetooth UUID of the service.
   64|       |    ///   - isPrimary: The type of the service (primary or secondary).
   65|      2|    init(type uuid: CBMUUID, primary isPrimary: Bool) {
   66|      2|        self.identifier = UUID()
   67|      2|        self.peripheral = uninitializedPeriperheral
   68|      2|        self._uuid = uuid
   69|      2|        self.isPrimary = isPrimary
   70|      2|    }
   71|       |    
   72|       |    internal init(shallowCopy service: CBMService,
   73|     20|                  for peripheral: CBMPeripheralMock) {
   74|     20|        self.identifier = service.identifier
   75|     20|        self.peripheral = peripheral
   76|     20|        self._uuid = service._uuid
   77|     20|        self.isPrimary = service.isPrimary
   78|     20|    }
   79|       |}
   80|       |
   81|       |internal class CBMServiceNative: CBMService {
   82|       |    let service: CBService
   83|       |    
   84|      0|    init(_ service: CBService, in peripheral: CBMPeripheral) {
   85|      0|        self.service = service
   86|      0|        super.init(type: service.uuid, primary: service.isPrimary)
   87|      0|        self.peripheral = peripheral
   88|      0|        self.isPrimary = service.isPrimary
   89|      0|                
   90|      0|        if let nativeCharacteristics = service.characteristics {
   91|      0|            _characteristics = nativeCharacteristics.map { CBMCharacteristicNative($0, in: self) }
   92|      0|        }
   93|      0|        
   94|      0|        if let nativeSecondaryServices = service.includedServices {
   95|      0|            _includedServices = nativeSecondaryServices.map { CBMServiceNative($0, in: peripheral) }
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    override func isEqual(_ object: Any?) -> Bool {
  100|      0|        if let other = object as? CBMServiceNative {
  101|      0|            return service == other.service
  102|      0|        }
  103|      0|        return false
  104|      0|    }
  105|       |    
  106|       |}
  107|       |
  108|       |open class CBMServiceMock: CBMService {
  109|       |
  110|       |    open override var includedServices: [CBMService]? {
  111|      0|        set { _includedServices = newValue }
  112|      0|        get { return _includedServices }
  113|       |    }
  114|       |
  115|       |    open override var characteristics: [CBMCharacteristic]? {
  116|      1|        set { _characteristics = newValue }
  117|    257|        get { return _characteristics }
  118|       |    }
  119|       |    
  120|       |    /// Returns a service, initialized with a service type and UUID.
  121|       |    /// - Parameters:
  122|       |    ///   - uuid: The Bluetooth UUID of the service.
  123|       |    ///   - isPrimary: The type of the service (primary or secondary).
  124|       |    ///   - characteristics: Optional list of characteristics.
  125|       |    public init(type uuid: CBMUUID, primary isPrimary: Bool,
  126|      1|                characteristics: CBMCharacteristicMock...) {
  127|      1|        super.init(type: uuid, primary: isPrimary)
  128|      1|        self.characteristics = characteristics
  129|      1|    }
  130|       |    
  131|      0|    open func contains(_ characteristic: CBMCharacteristicMock) -> Bool {
  132|      0|        return _characteristics?.contains(characteristic) ?? false
  133|      0|    }
  134|       |    
  135|      0|    open override func isEqual(_ object: Any?) -> Bool {
  136|      0|        if let other = object as? CBMServiceMock {
  137|      0|            return identifier == other.identifier
  138|      0|        }
  139|      0|        return false
  140|      0|    }
  141|       |}
  142|       |
  143|       |open class CBMCharacteristic: CBMAttribute {
  144|       |    internal let identifier: UUID
  145|       |    private let _uuid: CBMUUID
  146|       |    
  147|       |    internal var _descriptors: [CBMDescriptor]?
  148|       |    
  149|       |    /// The Bluetooth UUID of the attribute.
  150|    321|    open override var uuid: CBMUUID {
  151|    321|        return _uuid
  152|    321|    }
  153|       |
  154|       |    /// A back-pointer to the service this characteristic belongs to.
  155|       |    open internal(set) var service: CBMService
  156|       |    
  157|       |    /// The properties of the characteristic.
  158|       |    public let properties: CBMCharacteristicProperties
  159|       |
  160|       |    /// The value of the characteristic.
  161|       |    open internal(set) var value: Data?
  162|       |
  163|       |    /// A list of the descriptors that have so far been discovered
  164|       |    /// in this characteristic.
  165|      0|    open var descriptors: [CBMDescriptor]? {
  166|      0|        return _descriptors
  167|      0|    }
  168|       |
  169|       |    /// Whether the characteristic is currently notifying or not.
  170|       |    open internal(set) var isNotifying: Bool
  171|       |
  172|       |    /// Returns an initialized characteristic.
  173|       |    /// - Parameters:
  174|       |    ///   - uuid: The Bluetooth UUID of the characteristic.
  175|       |    ///   - properties: The properties of the characteristic.
  176|      3|    init(type uuid: CBMUUID, properties: CBMCharacteristicProperties) {
  177|      3|        self.identifier = UUID()
  178|      3|        self.service = uninitializedService
  179|      3|        self._uuid = uuid
  180|      3|        self.properties = properties
  181|      3|        self.isNotifying = false
  182|      3|    }
  183|       |    
  184|     20|    init(shallowCopy characteristic: CBMCharacteristic, in service: CBMService) {
  185|     20|        self.identifier = characteristic.identifier
  186|     20|        self.service = service
  187|     20|        self._uuid = characteristic._uuid
  188|     20|        self.properties = characteristic.properties
  189|     20|        self.isNotifying = false
  190|     20|    }
  191|       |}
  192|       |
  193|       |internal class CBMCharacteristicNative: CBMCharacteristic {
  194|       |    let characteristic: CBCharacteristic
  195|       |    
  196|      0|    init(_ characteristic: CBCharacteristic, in service: CBMService) {
  197|      0|        self.characteristic = characteristic
  198|      0|        super.init(type: characteristic.uuid, properties: characteristic.properties)
  199|      0|        self.service = service
  200|      0|        self.value = characteristic.value
  201|      0|        self.isNotifying = isNotifying
  202|      0|        
  203|      0|        if let nativeDescriptors = characteristic.descriptors {
  204|      0|            _descriptors = nativeDescriptors.map { CBMDescriptorNative($0, in: self) }
  205|      0|        }
  206|      0|    }
  207|       |    
  208|      0|    override func isEqual(_ object: Any?) -> Bool {
  209|      0|        if let other = object as? CBMCharacteristicNative {
  210|      0|            return characteristic == other.characteristic
  211|      0|        }
  212|      0|        return false
  213|      0|    }
  214|       |}
  215|       |
  216|       |open class CBMCharacteristicMock: CBMCharacteristic {
  217|       |
  218|       |    open override var descriptors: [CBMDescriptor]? {
  219|      2|        set {
  220|      2|            _descriptors = newValue
  221|      2|            _descriptors?.forEach { $0.characteristic = self }
  222|      2|        }
  223|      0|        get { return _descriptors }
  224|       |    }
  225|       |    
  226|       |    /// Returns an initialized characteristic.
  227|       |    /// - Parameters:
  228|       |    ///   - uuid: The Bluetooth UUID of the characteristic.
  229|       |    ///   - properties: The properties of the characteristic.
  230|       |    ///   - descriptors: Optional list of descriptors.
  231|       |    public init(type uuid: CBMUUID, properties: CBMCharacteristicProperties,
  232|      2|                descriptors: CBMDescriptorMock...) {
  233|      2|        super.init(type: uuid, properties: properties)
  234|      2|        self.descriptors = descriptors
  235|      2|    }
  236|       |    
  237|      0|    open func contains(_ descriptor: CBMDescriptor) -> Bool {
  238|      0|        return _descriptors?.contains(descriptor) ?? false
  239|      0|    }
  240|       |    
  241|    406|    open override func isEqual(_ object: Any?) -> Bool {
  242|    406|        if let other = object as? CBMCharacteristicMock {
  243|    406|            return identifier == other.identifier
  244|    406|        }
  245|      0|        return false
  246|    406|    }
  247|       |}
  248|       |
  249|       |open class CBMDescriptor: CBMAttribute {
  250|       |    internal let identifier: UUID
  251|       |    private let _uuid: CBMUUID
  252|       |    
  253|       |    /// The Bluetooth UUID of the attribute.
  254|      0|    open override var uuid: CBMUUID {
  255|      0|        return _uuid
  256|      0|    }
  257|       |    
  258|       |    /// A back-pointer to the characteristic this descriptor belongs to.
  259|       |    open internal(set) var characteristic: CBMCharacteristic
  260|       |
  261|       |    /// The value of the descriptor.
  262|       |    open internal(set) var value: Any?
  263|       |    
  264|       |    /// Returns <i>true</i> if the descriptor is a Client Configuration
  265|       |    /// Characteristic Descriptor (CCCD); otherwise <i>false</i>.
  266|      0|    internal var isCCCD: Bool {
  267|      0|        return uuid.uuidString == "2902"
  268|      0|    }
  269|       |    
  270|      1|    init(type uuid: CBMUUID) {
  271|      1|        self.identifier = UUID()
  272|      1|        self.characteristic = uninitializedCharacteristic
  273|      1|        self._uuid = uuid
  274|      1|    }
  275|       |    
  276|      0|    init(shallowCopy descriptor: CBMDescriptor, in characteristic: CBMCharacteristic) {
  277|      0|        self.identifier = descriptor.identifier
  278|      0|        self.characteristic = characteristic
  279|      0|        self._uuid = descriptor._uuid
  280|      0|    }
  281|       |}
  282|       |
  283|       |internal class CBMDescriptorNative: CBMDescriptor {
  284|       |    let descriptor: CBDescriptor
  285|       |    
  286|      0|    init(_ descriptor: CBDescriptor, in characteristic: CBMCharacteristic) {
  287|      0|        self.descriptor = descriptor
  288|      0|        super.init(type: descriptor.uuid)
  289|      0|        self.characteristic = characteristic
  290|      0|        self.value = descriptor.value
  291|      0|    }
  292|       |    
  293|      0|    override func isEqual(_ object: Any?) -> Bool {
  294|      0|        if let other = object as? CBMDescriptorNative {
  295|      0|            return descriptor == other.descriptor
  296|      0|        }
  297|      0|        return false
  298|      0|    }
  299|       |}
  300|       |
  301|       |open class CBMDescriptorMock: CBMDescriptor {
  302|       |    
  303|      1|    public override init(type uuid: CBMUUID) {
  304|      1|        super.init(type: uuid)
  305|      1|    }
  306|       |    
  307|      0|    open override func isEqual(_ object: Any?) -> Bool {
  308|      0|        if let other = object as? CBMDescriptorMock {
  309|      0|            return identifier == other.identifier
  310|      0|        }
  311|      0|        return false
  312|      0|    }
  313|       |}
  314|       |
  315|       |open class CBMClientCharacteristicConfigurationDescriptorMock: CBMDescriptorMock {
  316|       |    
  317|      1|    public init() {
  318|      1|        super.init(type: CBMUUID(string: "2902"))
  319|      1|    }
  320|       |}
  321|       |
  322|       |public typealias CBMCCCDescriptorMock = CBMClientCharacteristicConfigurationDescriptorMock
  323|       |
  324|       |// MARK: - Mocking uninitialized objects
  325|       |
  326|       |fileprivate let uninitializedPeriperheral   = CBMPeripheralUninitialized()
  327|       |fileprivate let uninitializedService        = CBMServiceUninitialized()
  328|       |fileprivate let uninitializedCharacteristic = CBMCharacteristicUninitialized()
  329|       |
  330|       |fileprivate class CBMPeripheralUninitialized: CBMPeripheral, CustomDebugStringConvertible {
  331|       |    let debugDescription: String = "<uninitialized>"
  332|       |    
  333|      0|    var identifier: UUID { uninitialized() }
  334|      0|    var name: String? { uninitialized() }
  335|      0|    var state: CBMPeripheralState { uninitialized() }
  336|      0|    var services: [CBMService]? { uninitialized() }
  337|      0|    var canSendWriteWithoutResponse: Bool { uninitialized() }
  338|      0|    var ancsAuthorized: Bool { uninitialized() }
  339|       |    var delegate: CBMPeripheralDelegate? {
  340|      0|        get { uninitialized() }
  341|      0|        set { uninitialized() }
  342|       |    }
  343|       |    
  344|      0|    func readRSSI() {
  345|      0|        uninitialized()
  346|      0|    }
  347|       |    
  348|      0|    func discoverServices(_ serviceUUIDs: [CBMUUID]?) {
  349|      0|        uninitialized()
  350|      0|    }
  351|       |    
  352|       |    func discoverIncludedServices(_ includedServiceUUIDs: [CBMUUID]?,
  353|      0|                                  for service: CBMService) {
  354|      0|        uninitialized()
  355|      0|    }
  356|       |    
  357|       |    func discoverCharacteristics(_ characteristicUUIDs: [CBMUUID]?,
  358|      0|                                 for service: CBMService) {
  359|      0|        uninitialized()
  360|      0|    }
  361|       |    
  362|      0|    func discoverDescriptors(for characteristic: CBMCharacteristic) {
  363|      0|        uninitialized()
  364|      0|    }
  365|       |    
  366|      0|    func readValue(for characteristic: CBMCharacteristic) {
  367|      0|        uninitialized()
  368|      0|    }
  369|       |    
  370|      0|    func readValue(for descriptor: CBMDescriptor) {
  371|      0|        uninitialized()
  372|      0|    }
  373|       |    
  374|      0|    func maximumWriteValueLength(for type: CBMCharacteristicWriteType) -> Int {
  375|      0|        uninitialized()
  376|      0|    }
  377|       |    
  378|       |    func writeValue(_ data: Data,
  379|       |                    for characteristic: CBMCharacteristic,
  380|      0|                    type: CBMCharacteristicWriteType) {
  381|      0|        uninitialized()
  382|      0|    }
  383|       |    
  384|      0|    func writeValue(_ data: Data, for descriptor: CBMDescriptor) {
  385|      0|        uninitialized()
  386|      0|    }
  387|       |    
  388|       |    func setNotifyValue(_ enabled: Bool,
  389|      0|                        for characteristic: CBMCharacteristic) {
  390|      0|        uninitialized()
  391|      0|    }
  392|       |    
  393|       |    @available(iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  394|      0|    func openL2CAPChannel(_ PSM: CBML2CAPPSM) { uninitialized() }
  395|       |    
  396|      0|    func uninitialized() -> Never {
  397|      0|        fatalError("Uninitialized")
  398|      0|    }
  399|       |}
  400|       |
  401|       |fileprivate class CBMServiceUninitialized: CBMService {
  402|      0|    override var debugDescription: String { return "<uninitialized>" }
  403|      0|    override var uuid: CBMUUID { uninitialized() }
  404|      0|    override var characteristics: [CBMCharacteristic]? { uninitialized() }
  405|       |    override var isPrimary: Bool {
  406|      0|        get { uninitialized() }
  407|      0|        set { uninitialized() }
  408|       |    }
  409|       |    
  410|      1|    init() {
  411|      1|        super.init(type: CBMUUID(), primary: true)
  412|      1|    }
  413|       |    
  414|      0|    func uninitialized() -> Never {
  415|      0|        fatalError("Uninitialized")
  416|      0|    }
  417|       |}
  418|       |
  419|       |fileprivate class CBMCharacteristicUninitialized: CBMCharacteristic {
  420|      0|    override var debugDescription: String { return "<uninitialized>" }
  421|      0|    override var uuid: CBMUUID { uninitialized() }
  422|      0|    override var descriptors: [CBMDescriptor]? { uninitialized() }
  423|       |    override var value: Data? {
  424|      0|        get { uninitialized() }
  425|      0|        set { uninitialized() }
  426|       |    }
  427|       |    override var isNotifying: Bool {
  428|      0|        get { uninitialized() }
  429|      0|        set { uninitialized() }
  430|       |    }
  431|       |    
  432|      1|    init() {
  433|      1|        super.init(type: CBMUUID(), properties: [])
  434|      1|    }
  435|       |    
  436|      0|    func uninitialized() -> Never {
  437|      0|        fatalError("Uninitialized")
  438|      0|    }
  439|       |}

